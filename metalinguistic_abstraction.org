* Metalinguistic Abstraction 

Metalinguistic Abstraction -- establishing new languages -- plays an important role in all branches of engineering design. An evaluator (or interpreter) for a programming language is a procedure that, when applied to an expression of the language, performs that actions required to evaluate that expression. 

The evaluator, which determines the meaning of expressions in a programming language, is just another program. 

* Metacircular Evaluator 
:PROPERTIES:
:header-args: :session scheme :results verbatim raw
:ARCHIVE:
:END:

An evaluator that is written in the same language that it evaluates is said to be metacircular. 

This is essentially a scheme formulation of the environment model of evaluation, which had two parts:

1. To evaluate a combination (a compound expression other than a special form), evaluate the subexpressions and then apply the value of the operator subexpression to the values of the operand subexpressions. 
2. To apply a compound procedure to a set of arguments, evaluate the body of the procedure in a new environment. To construct this environment, extend the environment part of the procedure object by a frame in which the formal parameters of the procedure are bound to the arguments to whcih the procedure is applied. 

These two rules describe the essence of the evaluation process, a basic cycle in which expressions to be evaluated in environments are reduced to procedures to be applied to arguments, which in turn are reduced to new expressions to be evaluated in new environments, and so on, until we get down to symbols, whose values are looked up in the environment, and to primitive procedures, which are applied directly. 

** The Core of the Evaluator 

The evaluation process can be described as the interplay between two procedures: eval and apply. 


*** Eval 

Eval takes as arguments an expression and an environment. It classifies the expression and directs its evaluation. Eval is structured as a case analysis of the syntactic type of the expression to be evaluated. To keep the procedure general, we express the determination of the type of an expression abstractly, making no commitment to any particular representation for the various types of expressions. Each type of expression has a predicate that tests for it and an abstract means for selecting its parts. This abstract syntax makes it easy to see how we can change the syntax of the language by using the same evaluator, but with a different collection of syntax procedures. 


**** Primitive Expressions 
- Numbers 
- Look up variables in the environment 

**** Special Forms 
- quoted expressions 
- assignment
- if expression
- lambda expression
- begin expression
- case analysis (cond)

**** Combinations 

For a procedure application, eval must recursively evaluate the operator part and the operands of the combination. The resulting procedure and argiments are passed to apply which handles the actual procedure application. 

#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure
                        (lambda-parameters exp)
                        (lambda-body exp)) env)
        ((begin? exp) (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else (error "Unknown expression type: EVAL" exp))))
#+END_SRC

#+RESULTS:

*** Apply 

Apply takes two arguments, a procedure and a list of arguments to which the procedures should be applied. It classifies procedures into two kinds:
- apply-primitive-procedure for primitives
- it applies compound procedures by sequentially evaluating the expressions that make up the body of the procedure

The environment for the evaluation of the body of a compound procedure is constructed by extending the base environment carried by the procedure to include a frame that binds the parameters of the prcedure to the arguments to which the procedure is to be applied. 

#+BEGIN_SRC scheme
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence (procedure-body procedure)
                        (extend-environment
                         (procedure-parameters procedure)
                         arguments
                         (procedure-environment procedure))))
        (else (error "Unknown procedure type: APPLY" procedure))))
#+END_SRC

**** Procedure Arguments

When eval processes a procedure application, it uses list-of-values to produce the list of arguments to which the procedure is to be applied. list-of-values takes as an argument the operands of the combination, evaluates each operand and returns a list of the corresponding values: 

#+BEGIN_SRC scheme
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values
             (rest-operands exps) env))))
#+END_SRC

#+RESULTS:
list-of-values

**** Conditionals

eval-if evalutes the predicate part of an if expression in the given environment. If the result is true, eval-if evalutes the consequent, otherwise the alternative. 

#+BEGIN_SRC scheme
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
#+END_SRC

#+RESULTS:
eval-if

The use of true? in eval-if highlights the issue of the connection between an implemented language and an implementation language. The if-predicate is evaluated in the language being implemented and thus yields a value in that language. The interpreter predicate true? translates that values into a value that can be tested by the if in the implementation language. The metacircular representation of truth might not be the same as that of the underlying Scheme. 

**** Sequences 

eval-sequence is used by apply to evaluate the sequence of expressions in a procedure body and by eval to evaluate the sequence of expressions in a begin expression. It takes as arguments a sequence of expressions and an environment and evaluates the expressions in the order in which they occur. The value returned is the value of the final expression: 

#+BEGIN_SRC scheme
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
#+END_SRC

**** Assignments and Definitions

The following procedure handles assignments to variables

#+BEGIN_SRC scheme
(define (eval-assignment exp env)
  (set-variable-value!
   (assignment-variable exp)
   (eval (assignment-value exp) env)
   env)
  'ok)

(define (eval-definition exp env)
  (define-variable!
    (definition-variable exp)
    (eval (definition-value exp) env)
    env)
  'ok)
#+END_SRC

***** Exercise 4.1

We cannot tell whether the metacircular evaluator evaluates operands from left to right or from right to left. 

Write a version of list-of-values that evaluates operands from left to right regardless of the order of evaluation in the underlying lisp. Also write a version that evaluates from right to left.

Here is the original

#+BEGIN_SRC scheme
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values
             (rest-operands exps) env))))
#+END_SRC 

We need to give proper names to each of the values and then cons them in a way that makes the order explicit 

#+BEGIN_SRC scheme
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let* ((left (eval (first-operand exps) env))
             (right (list-of-values (rest-operands exps) env)))
        (cons left right))))

(define (list-of-values-rl exps env)
  (if (no-operands? exps)
      '()
      (let* ((left (eval (first-operand exps) env))
             (right (list-of-values (rest-operands exps) env)))
        (cons right left))))
#+END_SRC

** Representing Expressions 

#+BEGIN_SRC scheme
; the only self evaluating items are numbers and strings
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variables are represented by symbols
(define (variable? exp)
  (symbol? exp))

; quotations have the form (quote <text of quotation>)
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp)
  (cadr exp))

; this identifies lists beginning with a designated symbol
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))

; assignments have the form (set! <var> <value>)
(define (asssignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp)
  (cadr exp))

(define (assignment-value exp)
  (caddr exp))

; definitions have the forms (define <var> <value>) or (define (<var> <param_1> ... <param_n>) <body>)
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)   ; formal parameters
                   (cddr exp)))) ; body

; lambda expressions are lists that begin with the symbol lambda 
(define (lambda? exp)
  (tagged-list? exp 'lambda))

(define (lambda-parameters exp)
  (cadr exp))

(define (lambda-body exp)
  (cddr exp))

; a constructor for lambda expressions 
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))

; conditionals begin with if and have a predicate, consequent, and alternative optionally 
(define (if? exp)
  (tagged-list? exp 'if))

(define (if-predicate exp)
  (cadr exp))

(define (if-consequent exp)
  (caddr exp))

(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

; a constructor for if expressions
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))

; begin packages a sequence of exps into a single exp
(define (begin? exp)
  (tagged-list? exp 'begin))

(define (begin-actions exp)
  (cdr exp))

(define (last-exp? seq)
  (null? (cdr seq)))

(define (first-exp seq)
  (car seq))

(define (rest-exps seq)
  (cdr seq))

; constructor to transform a seq into a single exp 
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))

(define (make-begin seq)
  (cons 'begin seq))

; a procedure app is any compound exp not found above. The car is the operator, and the cdr the operands
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
#+END_SRC

** Derived Expressions 

We can implement cond as a sequence of nested if statements 

#+BEGIN_SRC scheme
(define (cond? exp)
  (tagged-list? exp 'cond))

(define (cond-clauses exp)
  (cdr exp))

(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))

(define (cond-predicate clause)
  (car clause))

(define (cond-actions clause)
  (cdr clause))

(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clauses ins't last: COND->IF" clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
#+END_SRC

#+RESULTS:

expressions that we choose to implement as syntactic transformations are called derived expressions. Let expressions are also derived expressions. 

***** Exercise 4.2 

Louis Reasoner plans to reorder the cond clauses in eval so that the clause for procedure applications appears before the clause for assignments. He argues this will be more efficient, since programs usually contain more applications than assignments, definitions, and so on. 

1. What is wrong with Louis' plan?

If we look at the eval expression: 

#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure
                        (lambda-parameters exp)
                        (lambda-body exp)) env)
        ((begin? exp) (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else (error "Unknown expression type: EVAL" exp))))
#+END_SRC

We see that the application? takes an expression which is implemented as a pair, and from that pulls out the operator and operands, which it then compares in an environment. If we choose to swap the order, the language won't be able to treat the assignment as a special form, and it would then try to eval the operater on the expression. 

For the example (define x 3) we would see 

(application? '(define x 3))
(apply (eval (operator '(define x 3) env)
       (list-of-values (operands exp) env)))
(apply (eval define env)
       (list-of-values '(x 3) env))

(eval define env) would be problematic, because it would be looking for a definition for define in the env instead of treating it as a special form. 

2. Louis is willing to go to any lengths to make his evaluator recognize procedure applications before it checks most other kinds of expresssions. Help him change the syntax of the evaluated language so that procedure applications start with call.

#+BEGIN_SRC scheme
(define (call? exp)
  (tagged-list? exp 'call))

(define (call-operator exp)
  (cadr exp))

(define (call-operands exp)
  (cddr exp))
#+END_SRC

***** Exercise 4.3 

Rewrite eval so that the dispatch is done in data-directed style. 

Here is the original eval: 

#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure
                        (lambda-parameters exp)
                        (lambda-body exp)) env)
        ((begin? exp) (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else (error "Unknown expression type: EVAL" exp))))
#+END_SRC


#+BEGIN_SRC scheme
; table operations
(define op-table make-table)
(define get (op-table 'lookup-proc))
(define put (op-table 'insert-proc))

; eval operations
(put 'op 'quote text-of-quotation)
(put 'op 'set! eval-assignment)
(put 'op 'define eval-definition)
(put 'op 'if eval-if)
(put 'op 'lambda (lambda (exp env) (make-procedure (lambda-parameters exp) (lambda-body exp))))
(put 'op 'begin (lambda (exp env) (eval-sequence (begin-actions exp) env)))
(put 'op 'cond (lambda (exp env) (eval (cond-if exp) env)))
#+END_SRC

***** Exercise 4.4 

Install and and or as special forms for the evaluator by defining appropriate syntax procedures and evalution procedures eval-and and eval-or

#+BEGIN_SRC scheme
; accessors
(define (and? exp) (tagged-list? exp 'and))
(define (or? exp) (tagged-list? exp 'or))
(define (preds exp) (cdr exp))
(define (first-pred seq) (car seq))
(define (rest-preds seq) (cdr seq))
(define (no-pred? seq) (null? seq))

; expressions
(define (eval-and exp env)
  (cond ((no-pred? exp) #t)
        ((not (true? (eval (first-pred exp)))) #f)
        (else (eval-and (rest-preds exp) env))))

(define (eval-or exp env)
  (cond ((no-pred? exp) #f)
        ((true? (eval (first-pred exp))) #t)
        (else (eval-or (rest-preds exp) env))))
#+END_SRC

***** Exercise 4.5 


