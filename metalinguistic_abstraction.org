* Metalinguistic Abstraction 

Metalinguistic Abstraction -- establishing new languages -- plays an important role in all branches of engineering design. An evaluator (or interpreter) for a programming language is a procedure that, when applied to an expression of the language, performs that actions required to evaluate that expression. 

The evaluator, which determines the meaning of expressions in a programming language, is just another program. 

* Metacircular Evaluator 
:PROPERTIES:
:header-args: :session scheme :results verbatim raw
:ARCHIVE:
:END:

An evaluator that is written in the same language that it evaluates is said to be metacircular. 

This is essentially a scheme formulation of the environment model of evaluation, which had two parts:

1. To evaluate a combination (a compound expression other than a special form), evaluate the subexpressions and then apply the value of the operator subexpression to the values of the operand subexpressions. 
2. To apply a compound procedure to a set of arguments, evaluate the body of the procedure in a new environment. To construct this environment, extend the environment part of the procedure object by a frame in which the formal parameters of the procedure are bound to the arguments to whcih the procedure is applied. 

These two rules describe the essence of the evaluation process, a basic cycle in which expressions to be evaluated in environments are reduced to procedures to be applied to arguments, which in turn are reduced to new expressions to be evaluated in new environments, and so on, until we get down to symbols, whose values are looked up in the environment, and to primitive procedures, which are applied directly. 

** The Core of the Evaluator 

The evaluation process can be described as the interplay between two procedures: eval and apply. 


*** Eval 

Eval takes as arguments an expression and an environment. It classifies the expression and directs its evaluation. Eval is structured as a case analysis of the syntactic type of the expression to be evaluated. To keep the procedure general, we express the determination of the type of an expression abstractly, making no commitment to any particular representation for the various types of expressions. Each type of expression has a predicate that tests for it and an abstract means for selecting its parts. This abstract syntax makes it easy to see how we can change the syntax of the language by using the same evaluator, but with a different collection of syntax procedures. 


**** Primitive Expressions 
- Numbers 
- Look up variables in the environment 

**** Special Forms 
- quoted expressions 
- assignment
- if expression
- lambda expression
- begin expression
- case analysis (cond)

**** Combinations 

For a procedure application, eval must recursively evaluate the operator part and the operands of the combination. The resulting procedure and argiments are passed to apply which handles the actual procedure application. 

#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure
                        (lambda-parameters exp)
                        (lambda-body exp)) env)
        ((begin? exp) (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else (error "Unknown expression type: EVAL" exp))))
#+END_SRC

#+RESULTS:
eval

*** Apply 

Apply takes two arguments, a procedure and a list of arguments to which the procedures should be applied. It classifies procedures into two kinds:
- apply-primitive-procedure for primitives
- it applies compound procedures by sequentially evaluating the expressions that make up the body of the procedure

The environment for the evaluation of the body of a compound procedure is constructed by extending the base environment carried by the procedure to include a frame that binds the parameters of the prcedure to the arguments to which the procedure is to be applied. 

#+BEGIN_SRC scheme
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence (procedure-body procedure)
                        (extend-environment
                         (procedure-parameters procedure)
                         arguments
                         (procedure-environment procedure))))
        (else (error "Unknown procedure type: APPLY" procedure))))
#+END_SRC

#+RESULTS:
apply
apply
apply

**** Procedure Arguments

When eval processes a procedure application, it uses list-of-values to produce the list of arguments to which the procedure is to be applied. list-of-values takes as an argument the operands of the combination, evaluates each operand and returns a list of the corresponding values: 

#+BEGIN_SRC scheme
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values
             (rest-operands exps) env))))
#+END_SRC

#+RESULTS:
list-of-values
list-of-values
list-of-values
list-of-values
list-of-values

**** Conditionals

eval-if evalutes the predicate part of an if expression in the given environment. If the result is true, eval-if evalutes the consequent, otherwise the alternative. 

#+BEGIN_SRC scheme
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
#+END_SRC

#+RESULTS:
eval-if
eval-if
eval-if
eval-if
eval-if
eval-if

The use of true? in eval-if highlights the issue of the connection between an implemented language and an implementation language. The if-predicate is evaluated in the language being implemented and thus yields a value in that language. The interpreter predicate true? translates that values into a value that can be tested by the if in the implementation language. The metacircular representation of truth might not be the same as that of the underlying Scheme. 

**** Sequences 

eval-sequence is used by apply to evaluate the sequence of expressions in a procedure body and by eval to evaluate the sequence of expressions in a begin expression. It takes as arguments a sequence of expressions and an environment and evaluates the expressions in the order in which they occur. The value returned is the value of the final expression: 

#+BEGIN_SRC scheme
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
#+END_SRC

#+RESULTS:
eval-sequence
eval-sequence
eval-sequence
eval-sequence
eval-sequence

**** Assignments and Definitions

The following procedure handles assignments to variables

#+BEGIN_SRC scheme
(define (eval-assignment exp env)
  (set-variable-value!
   (assignment-variable exp)
   (eval (assignment-value exp) env)
   env)
  'ok)

(define (eval-definition exp env)
  (define-variable!
    (definition-variable exp)
    (eval (definition-value exp) env)
    env)
  'ok)
#+END_SRC

#+RESULTS:
eval-definition
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]

***** Exercise 4.1

We cannot tell whether the metacircular evaluator evaluates operands from left to right or from right to left. 

Write a version of list-of-values that evaluates operands from left to right regardless of the order of evaluation in the underlying lisp. Also write a version that evaluates from right to left.

Here is the original

#+BEGIN_SRC scheme
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values
             (rest-operands exps) env))))
#+END_SRC 

#+RESULTS:
list-of-values
list-of-values
list-of-values
list-of-values
list-of-values

We need to give proper names to each of the values and then cons them in a way that makes the order explicit 

#+BEGIN_SRC scheme
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let* ((left (eval (first-operand exps) env))
             (right (list-of-values (rest-operands exps) env)))
        (cons left right))))

(define (list-of-values-rl exps env)
  (if (no-operands? exps)
      '()
      (let* ((left (eval (first-operand exps) env))
             (right (list-of-values (rest-operands exps) env)))
        (cons right left))))
#+END_SRC

** Representing Expressions 

#+BEGIN_SRC scheme
; the only self evaluating items are numbers and strings
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))

; variables are represented by symbols
(define (variable? exp)
  (symbol? exp))

; quotations have the form (quote <text of quotation>)
(define (quoted? exp)
  (tagged-list? exp 'quote))

(define (text-of-quotation exp)
  (cadr exp))

; this identifies lists beginning with a designated symbol
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))

; assignments have the form (set! <var> <value>)
(define (asssignment? exp)
  (tagged-list? exp 'set!))

(define (assignment-variable exp)
  (cadr exp))

(define (assignment-value exp)
  (caddr exp))

; definitions have the forms (define <var> <value>) or (define (<var> <param_1> ... <param_n>) <body>)
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))

(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)   ; formal parameters
                   (cddr exp)))) ; body

; lambda expressions are lists that begin with the symbol lambda 
(define (lambda? exp)
  (tagged-list? exp 'lambda))

(define (lambda-parameters exp)
  (cadr exp))

(define (lambda-body exp)
  (cddr exp))

; a constructor for lambda expressions 
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))

; conditionals begin with if and have a predicate, consequent, and alternative optionally 
(define (if? exp)
  (tagged-list? exp 'if))

(define (if-predicate exp)
  (cadr exp))

(define (if-consequent exp)
  (caddr exp))

(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

; a constructor for if expressions
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))

; begin packages a sequence of exps into a single exp
(define (begin? exp)
  (tagged-list? exp 'begin))

(define (begin-actions exp)
  (cdr exp))

(define (last-exp? seq)
  (null? (cdr seq)))

(define (first-exp seq)
  (car seq))

(define (rest-exps seq)
  (cdr seq))

; constructor to transform a seq into a single exp 
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))

(define (make-begin seq)
  (cons 'begin seq))

; a procedure app is any compound exp not found above. The car is the operator, and the cdr the operands
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
#+END_SRC

#+RESULTS:
rest-operands
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]

** Derived Expressions 

We can implement cond as a sequence of nested if statements 

#+BEGIN_SRC scheme
(define (cond? exp)
  (tagged-list? exp 'cond))

(define (cond-clauses exp)
  (cdr exp))

(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))

(define (cond-predicate clause)
  (car clause))

(define (cond-actions clause)
  (cdr clause))

(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clauses ins't last: COND->IF" clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
#+END_SRC

#+RESULTS:
expand-clauses
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]

expressions that we choose to implement as syntactic transformations are called derived expressions. Let expressions are also derived expressions. 

***** Exercise 4.2 

Louis Reasoner plans to reorder the cond clauses in eval so that the clause for procedure applications appears before the clause for assignments. He argues this will be more efficient, since programs usually contain more applications than assignments, definitions, and so on. 

1. What is wrong with Louis' plan?

If we look at the eval expression: 

#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure
                        (lambda-parameters exp)
                        (lambda-body exp)) env)
        ((begin? exp) (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else (error "Unknown expression type: EVAL" exp))))
#+END_SRC

#+RESULTS:
eval
eval
eval
eval
eval

We see that the application? takes an expression which is implemented as a pair, and from that pulls out the operator and operands, which it then compares in an environment. If we choose to swap the order, the language won't be able to treat the assignment as a special form, and it would then try to eval the operater on the expression. 

For the example (define x 3) we would see 

(application? '(define x 3))
(apply (eval (operator '(define x 3) env)
       (list-of-values (operands exp) env)))
(apply (eval define env)
       (list-of-values '(x 3) env))

(eval define env) would be problematic, because it would be looking for a definition for define in the env instead of treating it as a special form. 

2. Louis is willing to go to any lengths to make his evaluator recognize procedure applications before it checks most other kinds of expresssions. Help him change the syntax of the evaluated language so that procedure applications start with call.

#+BEGIN_SRC scheme
(define (call? exp)
  (tagged-list? exp 'call))

(define (call-operator exp)
  (cadr exp))

(define (call-operands exp)
  (cddr exp))
#+END_SRC

#+RESULTS:
call-operands
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]

***** Exercise 4.3 

Rewrite eval so that the dispatch is done in data-directed style. 

Here is the original eval: 

#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure
                        (lambda-parameters exp)
                        (lambda-body exp)) env)
        ((begin? exp) (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else (error "Unknown expression type: EVAL" exp))))
#+END_SRC

#+RESULTS:
eval
eval
eval
eval
eval


#+BEGIN_SRC scheme
; table operations
(define op-table make-table)
(define get (op-table 'lookup-proc))
(define put (op-table 'insert-proc))

; eval operations
(put 'op 'quote text-of-quotation)
(put 'op 'set! eval-assignment)
(put 'op 'define eval-definition)
(put 'op 'if eval-if)
(put 'op 'lambda (lambda (exp env) (make-procedure (lambda-parameters exp) (lambda-body exp))))
(put 'op 'begin (lambda (exp env) (eval-sequence (begin-actions exp) env)))
(put 'op 'cond (lambda (exp env) (eval (cond-if exp) env)))
#+END_SRC

#+RESULTS:

***** Exercise 4.4 

Install and and or as special forms for the evaluator by defining appropriate syntax procedures and evalution procedures eval-and and eval-or

#+BEGIN_SRC scheme
; accessors
(define (and? exp) (tagged-list? exp 'and))
(define (or? exp) (tagged-list? exp 'or))
(define (preds exp) (cdr exp))
(define (first-pred seq) (car seq))
(define (rest-preds seq) (cdr seq))
(define (no-pred? seq) (null? seq))

; expressions
(define (eval-and exp env)
  (cond ((no-pred? exp) #t)
        ((not (true? (eval (first-pred exp)))) #f)
        (else (eval-and (rest-preds exp) env))))

(define (eval-or exp env)
  (cond ((no-pred? exp) #f)
        ((true? (eval (first-pred exp))) #t)
        (else (eval-or (rest-preds exp) env))))
#+END_SRC

#+RESULTS:
eval-or
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]

***** Exercise 4.5 

Scheme allows an additional syntax for cond clauses, (<test> => <recipient>). If test is true, then recipient is evaluted.

for example 

#+BEGIN_SRC scheme
(cond ((assoc 'b '((a 1) (b 2))) => cadr)
      (else false))
#+END_SRC

#+RESULTS:
2
2
2
2

Modify the handling of cond so that it supports this syntax. 

From schemewiki

Here is the original definition of cond: 

#+BEGIN_SRC scheme
(define (cond? exp)
  (tagged-list? exp 'cond))

(define (cond-clauses exp)
  (cdr exp))

(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))

(define (cond-predicate clause)
  (car clause))

(define (cond-actions clause)
  (cdr clause))

(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))

(define (expand-clauses clauses)
  (if (null? clauses)
      'false ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clauses isn't last: COND->IF" clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
#+END_SRC

#+RESULTS:
expand-clauses
#[constant 40 #x2]
#[constant 40 #x2]
#[constant 40 #x2]

We wish to extend it to handle (<test> => <recipient>).

We need to do the following: 
- check if the cadr is =>, with cond-actions
- add the condition for => to our expand clauses function

#+BEGIN_SRC scheme
(define (expand-clauses clauses)
  (if (null? clauses)
      'false ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clauses isn't last: COND->IF" clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest)))
        (if (eq? (cond-actions first) '=>)
            (make-if (cond-predicate first)
                     (cadr (cond-actions first))
                     (expand-clauses rest))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
#+END_SRC

#+RESULTS:
expand-clauses
expand-clauses
expand-clauses

***** Exercise 4.6 

Implement a syntactic transformation let->combination that reduces evaluating let expressions to evaluating combinations of the type shown here, and add the appropriate clause to eval to handle let expressions.

thoughts: similar to cond, except instead to translating cond to a sequence of nested if statements we wish to translate let 

(let ((v1 exp1)(v2 exp2)...(vn expn)) body) 

to 

((lambda (v1 v2 ... vn)) body)

#+BEGIN_SRC scheme
; find let
(define (let? exp) (tagged-list? exp 'let))

; get components
(define (let-vars exp)
  (map car (cadr exp)))

(define (let-exps exp)
  (map cadr (cadr exp)))

(define (let-body exp)
  (cddr exp))

; translate to lambda using our new languages make-lambda
(define (let->combination exp)
  (cons (make-lambda (let-vars exp) (let-body exp))
        (let-exps exp)))

; place inside of eval function 
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp) (make-procedure
                        (lambda-parameters exp)
                        (lambda-body exp)) env)
        ((begin? exp) (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((let? exp) (eval (let->combination exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else (error "Unknown expression type: EVAL" exp))))
#+END_SRC

#+RESULTS:
eval
#[constant 40 #x2]
#[constant 40 #x2]

***** Exercise 4.7 

let* is similar to let, except that the bindings of the let* variables are performed sequentially from left to right, and each binding is made in an environment in which all of the preceding bindings are visible. 

#+BEGIN_SRC scheme
(let* ((x 3)
       (y (+ x 2))
       (z (+ x y 5)))
  (* x z))
#+END_SRC

#+RESULTS:
39
39
39

Explain how a let* expression can be rewritten as a set of nested let expressions and write a procedire let*->nested-lets that performs the transformation. 

thoughts: we have let. This would likely be implemented in the same way that cond is implemented as a sequence of nested ifs. 

What we want is to take something like above:

(let* ((x 3)
       (y (+ x 2))
       (z (+ x y 5)))
  (* x z))

and turn it into the following: 

#+BEGIN_SRC scheme
(let ((x 3)
      (let ((y (+ x 2)))
        (let ((z (+ x y 5))))))
  (* x z))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC scheme
(define (let*? exp) (tagged-list? exp 'let*))

; get components
(define (let*-exps exp)
  (cadr exp))

(define (let*-body exp)
  (cddr exp))

; translate to lambda using our new languages make-lambda
(define (let*->nested exp)
  (define (make-let args body)
    (cons 'let (cons args body)))
  (define (unravel-let args body)
    (if (null? args)
        (sequence->exp body)
        (make-let (list (car args))
                  (list (unravel-let (cdr args) body)))))
  (unravel-let (let*-exps exp) (let*-body exp)))

(let*->nested '(let* ((x 1) (y 2)) x y))
#+END_SRC

#+RESULTS:
| let | ((x 1)) | (let ((y 2)) (begin x y)) |
(let ((x 1)) (let ((y 2)) (begin x y)))


***** Exercise 4.8 

Named let is a variant of let that has the form (let var bindings body)


** Evaluator Data Structures 

In addition to defining the external syntax of expressions, the evaluator must also define the data structures that the evaluator manipulates internally as part of the execution of a program, such as the representation of procedures and environments and the representation of true and false. 

** Testing of Predicates 

#+BEGIN_SRC scheme
(define (true? x)
  (not (eq? x false)))

(define (false? x)
  (eq? x false))
#+END_SRC

#+RESULTS:
false?
#[constant 40 #x2]

** Representing Procedures

To handle primitives, we assume we have some procedures. These are defined further down

#+BEGIN_SRC scheme
(define (apply-primitive proc args))

(define (primitive-procedure? proc))
#+END_SRC

#+RESULTS:

Compound procedures are constructed from parameters, procedure bodies and environments using the constructor make-procedure 

#+BEGIN_SRC scheme
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))

(define (compound-procedure? p)
  (tagged-list? p 'procedure))

(define (procedure-parameters p)
  (cadr p))

(define (procedure-body p)
  (caddr p))

(define (procedure-environment p)
  (cadddr p))
#+END_SRC

#+RESULTS:
procedure-environment
#[constant 40 #x2]

** Operations on Environments 

The evaluator needs operations for manipulating environments. Our environment is a sequence of frames, where each frame is a table of bindings that associate variables with their corresponding values. 

- (lookup-variable-var var env) returns the value that is bound to the symbol var in the environment or signals an error if the variable is unbound
- (extend-environment variables values base-env) returns a new environment, where the new vars and vals are enclosed by the base env
- (define-variable! var value env) adds to the first frame in the environment a new binding that ssociated the variable with the value
- (set-variable-value! var val env) changes the binding of the variable in the environment

To implement these, we represent the environment as a list of frames. 

#+BEGIN_SRC scheme
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
#+END_SRC

#+RESULTS:
the-empty-environment
#[constant 40 #x2]

Each frame of an environment is now represented as a pair of lists: 
- a list of the variables bound in that frame
- a list of the associated values 

#+BEGIN_SRC scheme
(define (make-frame variables values)
  (cons variables values))

(define (frame-variables frame)
  (car frame))

(define (frame-values frame)
  (cdr frame))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
#+END_SRC

#+RESULTS:
add-binding-to-frame!
#[constant 40 #x2]

To extend an environment by a new frame that associates variables with values, we make a frame consisting of the list of variables and the list of values and we adjoin this to the environment. 

#+BEGIN_SRC scheme
(define (extend-environment vars vals base-env)
  (if (= (length vars)
         (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars)
             (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
#+END_SRC

#+RESULTS:
extend-environment
extend-environment

To look up a variable in an environment, we scan a list of variables in the first frame. If we find the desired variable, we return the corresponding element in the list of values. If we do not find the variable in the current frame, we search the enclosing environment, as so on. If we reach an empty environment, we signal an unbound variable error. 

#+BEGIN_SRC scheme
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan var vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound Variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
#+END_SRC

#+RESULTS:
lookup-variable-value
lookup-variable-value

To set a variable to a new value in a specified environment, we scan for the variable, just as in lookup-variable-value and change the corresponding value when we find it 

#+BEGIN_SRC scheme
(define (set-variable-var! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars) (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable: SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
#+END_SRC

#+RESULTS:
set-variable-var!
set-variable-var!

To define a variable, we search the first frame for a binding for the variable, and change the binding if it exists. If no such binding exists, we adjoin one to the data frame. 

#+BEGIN_SRC scheme
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
#+END_SRC

#+RESULTS:
define-variable!
define-variable!

*** Exercise 4.11 

Instead of representing a frame as a pair of lists, we can represent a frame as a list of bindings, where each binding is a name-value pair. Rewrite the environment operations to use this alternative representation. 

#+BEGIN_SRC scheme
(define (make-frame variables values)
  (cond ((not (= (length variables) (length values)))
         (error "lengths must be equal" variables values))
        ((null? (cdr variables))
         (cons (car variables)
               (car values)))
        (else (cons (cons (car variables)
                          (car values))
                    (make-frame (cdr variables)
                                (cdr values))))))

; better version from schemewiki 
(define (make-frame variables values)
  (if (= (length variables)
         (length values))
      (map cons variables values)
      (error "args must be same length" variables values)))

; rest are mine
(define (frame-variables frame)
  (map car frame))

(define (frame-values frame)
  (map cdr frame))

(define (add-binding-to-frame! var val frame)
  (cons (cons var val)
        frame))
#+END_SRC

#+RESULTS:
add-binding-to-frame!

*** Exercise 4.12 

The procedures define-variable!, set-variable-value!, and lookup-variable-value can be expressed in terms of more abstract procedures for traversing the environment structure. 

Define abstractions that capture these common patterns and redefine the three procedures in terms of these abstractions.

To start, here are the three procedures: 

#+BEGIN_SRC scheme

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals env)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))

(define (set-variable-var! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars) (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable: SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound Variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))

#+END_SRC

#+RESULTS:
lookup-variable-value

These all essentially have the same pattern with only a slightly different operation happening in the env. We want to write a more general version of scan to be used across all three.

define-variable

    (define (scan vars vals env)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))

set-variable-var 

    (define (scan vars vals)
      (cond ((null? vars) (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))

lookup variable var 

    (define (scan var vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))

Similarly, both set-variable-var and lookup-variable-var have identical env-loop functions (with the exception of the error message) which rely on scan. 

  (define (env-loop env)
    (if (eq? env the-empty-environment)
        (error "Unbound Variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))

We can tease this apart by generalizing and passing functions for specific operations. Then we can use message passing to create a var-ops function

#+BEGIN_SRC scheme
(define (var-opt var val env op)
    ; define scan 
  (define (scan-gen vars vals)
    (cond ((null? vars) nll)
          ((eq? var (car vars))
           found)
          (else (scan (cdr vars)
                      (cdr vals)))))
    ; define env loop 
  (define (env-loop env)
    (if (eq? env the-empty-environment)
        (error "Unbound Variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
    ; define operation function 
  (define (define-variable! nll found)
    (let ((frame (first-frame env)))
      (scan (frame-variable frame)
            (frame-values frame)
            nll
            found)))
  (define (other-opt nll found)
    (let ((scan (scan nll found)))
      (env-loop env)))
  (define dispatch
    (cond ((eq? op 'define)
           (define-variable! (lambda () (add-binding-to-frame! var val frame))
             (lambda () (set-car! vars val))))
          ((eq? op 'set)
           (other-opt (lambda () (env-loop (enclosing-environment env)))
                      (lambda () (set-car! vals val))))
          ((eq? op 'lookup)
           (other-opt (lambda () (env-loop (enclosing-environment env)))
                      (lambda () (car vals))))
          (else (error "Unrecognized option" op)))))
#+END_SRC

#+RESULTS:
var-opt

*** Exercise 4.13 

Scheme allows is to create new bindings for variables by means of define, but provides no way to get rid of bindings. Implement for the evaluator the special form make-unbound! that removes the binding of a given symbol from the environment. 

Here is lookup-variable for reference

#+BEGIN_SRC scheme
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound Variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
#+END_SRC

#+RESULTS:
lookup-variable-value

#+BEGIN_SRC scheme
(define (make-unbound! var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (error "No bound var to unbind!" var))
            ((eq? var (car vars))
             (set-cdr! vars '())
             (set-cdr! vals '()))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Environment is empty!")
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
#+END_SRC

#+RESULTS:
make-unbound!


** Running the Evaluator as a Program 

#+BEGIN_SRC scheme
(define (setup-environment)
  (let ((initial-env (extend-environment (primitive-procedure-names)
                                         (primitive-procedure-objects)
                                         the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))

(define the-global-environment (setup-environment))
#+END_SRC

We have chosen to represent a primitive procedure as a list beginning with the symbol primitive and containing a procedure in the underlying lisp that implements that primitive 

#+BEGIN_SRC scheme
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

(define (primitive-implementation proc)
  (cadr proc))
#+END_SRC

setup-environment will get the primitive names and implementation procedures from a list 

#+BEGIN_SRC scheme
(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)))

(define (primitive-procedure-names)
  (map car primitive-procedures))

(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))

; to apply primitives, we apply the implementation procedure to the arguments
(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme (primitive-implementation proc) args))
#+END_SRC

Now we define a REPL of sorts 

#+BEGIN_SRC scheme
(define input-prompt ";;; M-Eval input:")

(define output-prompt ";;; M-Eval value:")

(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))

(define (prompt-for-input string)
  (newline)
  (newline)
  (display string)
  (newline))

(define (announce-output string)
  (newline)
  (display string)
  (newline))

(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))
#+END_SRC

Now all thats left is to initialize the global environment and start the loop 

#+BEGIN_SRC scheme
(define the-global-environment (setup-environment))
(driver-loop)

(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
#+END_SRC

