* Logic Programming 
:PROPERTIES:
:header-args: :session scheme :results verbatim raw
:ARCHIVE:
:END:

In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with relations rather than with single-valued functions. Logic programming extends this idea by combining a relational vision of programming with a powerful kind of symbolic pattern matching called unification. 

When this approach works, we get a very powerful way to write programs. Part of that power comes from the fact that a single "what is" fact can be used to solve a number of different problems that would have different "how to" components. 

** Deductive Information Retrieval

Logic programming excels in providing interfaces to databases for information retrieval. 

** Simple Queries 

The query language allows users to retrieve information from the database by posing queries in response to the system's prompt. 

#+BEGIN_SRC scheme
; query
(job ?x (computer programmer))

; results
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
#+END_SRC

The input query specifies that we are looking for entries in the database that match a certain pattern. 

We can describe the query language's processing of simple queries as follows: 

- The system finds all assignments to variables in the query pattern that satisfy the pattern -- that is, all sets of values for the variables such that if the pattern variables are instantiated with (replaced by) the values, the result is in the database.
- The system responds to the query by listing all instantiations of the query pattern with the variable assignments that satisfy it 

*** Exercise 4.55 

Give simple queries that retrieve the following information from the database: 

1. All people supervised by Ben Bitdiddle 

#+BEGIN_SRC scheme
(supervisor ?x (Bitdiddle Ben))
#+END_SRC

2. The names and jobs of all people in the accounting division 

#+BEGIN_SRC scheme
(job ?x (accounting . ?type))
#+END_SRC

3. The names and addresses of all people who live in slumerville 

#+BEGIN_SRC scheme
(address ?x (Slumerville . ?type))
#+END_SRC

** Compound Queries 

One thing that makes the query language a logic programming language is that the means of combination mirror the means of combination used in forming logical expressions: and, or, and not. 

We can chain them together like so: 

#+BEGIN_SRC scheme
(and (job ?person (computer programmer))
     (address ?person ?where))
#+END_SRC

In general, (and (q1)(q2)...(qn)) is satisfied by all sets of values for the pattern variables that simultaneously satisfy queries 1 through n. 
The same holds for or and not 

There is also a combining form called lisp-value. When lisp-value is the first element of a pattern, it specifies the next element is a lisp predicate to be applied to the rest of the instantiated elements as arguments. In general (lisp-value predicate arg1 ... argn) will be satisfied by assignments to the pattern variables for which the predicate applied to the instantiated arg1 ... argn is true. 

for example: 

#+BEGIN_SRC scheme
(and (salary ?person ?amount)
     (lisp-value > ?amount 30000))
#+END_SRC

*** Exercise 4.56 

Formulate compound queries that retrieve the following information: 

1. The names of all people who are supervised by Ben Bitdiddle and their addresses 

#+BEGIN_SRC scheme
(and (supervisor ?person (Bitdiddle Ben))
     (address ?person ?where))
#+END_SRC

2. All people whose salary is less than Bens, together with their salary and Bens salary 

#+BEGIN_SRC scheme
(and (salary (Bitdiddle Ben) ?amount)
     (salary ?person (lisp-value <= ?new-sal ?amount)))
#+END_SRC

3. All people who are supervised by someone who is not in the computer division, together with the supervisor's name and job 

#+BEGIN_SRC scheme
(and (supervisor ?person ?boss)
     (not (job ?boss (computer . ?type)))
     (job ?boss ?job))
#+END_SRC

** Rules 

In addition to primitive queries and compound queries, the query language provides means for abstracting queries. These are given by rules. 

The rule 

#+BEGIN_SRC scheme
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
#+END_SRC

specifies that two people live near each other if they live in the same town. 

The same relation is specified by a very simple rule 

#+BEGIN_SRC scheme
(rule (same ?x ?x))
#+END_SRC

The following rule declares that a person is a wheel in an organization if they supervise someone who is in turn a supervisor: 

#+BEGIN_SRC scheme
(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
#+END_SRC

The general form of a rule is 

#+BEGIN_SRC scheme
(rule <conclusion> <body>)
#+END_SRC

where conclusion is a pattern and body is any query. 

As in the case of compound procedures, rules can be used as parts of other rules, or even be defined recursively

For instance, this rule says that a staff person is outranked by a boss in the organization if the boss is the person's supervisor, or (recursively) if the person's supervisor is outranked by the boss. 

#+BEGIN_SRC scheme
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
#+END_SRC

*** Exercise 4.57 

Define a rule that says that person 1 can replace person 2 if either person 1 does the same job as person 2 or someone who does person 1's job can also do person 2's job, and if person 1 and person 2 are not the same person 

#+BEGIN_SRC scheme
(rule (replace ?person1 ?person2)
      (and
       ; get p1 job 
       (job ?person1 ?job1)
       ; get p2 job
       (job ?person2 ?job2)
       ; does p1 do the same job as p2? 
       (or (can-do-job ?person1 ?job2)
           ; can someone else do both jobs?
           (and (can-do-job ?person3 ?job1)
                (can-do-job ?person3 ?job2)))
       ; is anyone the same?
       (and (not (same ?person1 ?person2))
            (not (same ?person2 ?person3)))))
#+END_SRC

Using your rule, give queries that find the following: 

1. All people who can replace Cy D. Fect 

#+BEGIN_SRC scheme
(replace ?person (D-Fect Cy))
#+END_SRC

2. All people who can replace someone who is being paid more than they are, together with the two salaries

#+BEGIN_SRC scheme
(and (replace ?person1 ?person2)
     (salary ?person1 ?amount1)
     (salary ?person2 ?amount2)
     (lisp-value < ?amount1 ?amount2))
#+END_SRC


*** Exercise 4.58 

Define a rule that says that a person is a "big shot" in a division if the person works in the division, but does not have a supervisor who works in the division. 

#+BEGIN_SRC scheme
(rule (big-shot ?person)
      (and (job ?person ?division . ?rest)
          (or (and (supervisor ?person ?boss)
                   (not (job ?boss ?division . ?rest)))
              (not (same ?person ?boss)))))
#+END_SRC

*** Exercise 4.59 

Ben adds all his weekly meetings to the Microshaft database by asserting the following: 

#+BEGIN_SRC scheme
(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
(meeting whole-company (Wednesday 4pm))
#+END_SRC

1. On Friday mornings, Ben wants to query the database for all the meetings that occur that day. What query should he use? 

#+BEGIN_SRC scheme
(meeting ?dept (Friday ?time))
#+END_SRC

2. Alyssa thinks it would be more useful to ask for her meetings by specifying her name. She designs a rule that says that a person's meetings include all whole-company meetings plus all meetings of that person's division. Fill in the body of her rule: 

#+BEGIN_SRC scheme
(rule (meeting-time ?person ?day-and-time)
      (or (meeting whole-company (?day-and-time))
          (and (job ?person (?dept . ?rest))
               (meeting ?dept (?day-and-time)))))
#+END_SRC

3. Alyssa wonders what meetings she has to attend on Wednesday. What query should she make to find out? 

#+BEGIN_SRC scheme
(meeting-time (P.Hacker Alyssa) (Wednesday . ?time))
#+END_SRC

*** Exercise 4.60 

Alyssa notices that when she gives a query that is symmetric, she gets both results back and there appears to be duplicates. Why does this happen? 

- This happens because the relation is symmetric, i.e. arb <-> bra

Is there a way to find a list of people who line near each other, in which each pair appears only once? 

You could sort each tuple alphabetically and remove duplicates. 

** Logic as Programs 

We can regard a rule as a kind of logical implication: If an assignment of values to pattern variables satisfies the body, then it satisfies the conclusion. Consequently, we can regard the query language as having the ability to perform logical deductions based upon the rules. 

Consider the append operation characterized by the following two rules: 

- For any list y, the empty list and y append to form y
- For any u, v, y, z, (cons u v) and y append to form (cons u z) if v and y append to form z

To express this in our query language, we define two rules for a relation: 

#+BEGIN_SRC scheme
; x and y append to form z
(append-to-form x y z)

; holds for any value of ?y
(rule (append-to-form () ?y ?y))

(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
#+END_SRC


Given these two rules, we can formulate queries that compute the append of two lists: 

#+BEGIN_SRC scheme
; input
(append-to-form (a b) (c d) ?z)

; result
(append-to-form (a b) (c d) (a b c d))
#+END_SRC

We can also ask for all pairs of lists that append to form (a b c d)

#+BEGIN_SRC scheme
(append-to-form ?x ?y (a b c d))

(() (a b c d))
((a) (b c d))
((a b) (c d))
((a b c) (d))
((a b c d) ())
#+END_SRC

*** Exercise 4.61 

The following rules implement a next-to relation that finds adjacent elements of a list 

#+BEGIN_SRC scheme
(rule (?x next-to ?y in (?x ?y . ?u)))
(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
#+END_SRC

What will be the response for the following queries?

#+BEGIN_SRC scheme
; query 
(?x next-to ?y in (1 (2 3) 4))

; response
(1 (2 3))
((2 3) 4)
#+END_SRC

#+BEGIN_SRC scheme
; query
(?x next-to 1 in (2 1 3 1))

; response
(2)
(3)
#+END_SRC

*** Exercise 4.62 

Define rules to implement the last-pair operation, which returns a list containing the last element of a nonempty list.

#+BEGIN_SRC scheme
(rule (last-pair (?x) (?x)))
(rule (last-pair (?u . ?v) ?x)
      (last-pair ?v (?x)))
#+END_SRC

Check the rules on queries like 

#+BEGIN_SRC scheme
(last-pair (3) ?x)

; result
(last-pair (3) (3))

(last-pair (1 2 3) ?x)

; result
(last-pair (2 3) (3))

(last-pair (2 ?x) (3))

; result 
(last-pair (2 3) (3))

(last-pair ?x (3))

; result
(error "???")
#+END_SRC

*** Exercise 4.63 

Formulate rules such as 

if S is the son of F, and F is the son of G, then S is the grandson of G 

#+BEGIN_SRC scheme
(rule (grandson ?s ?g)
      (and (son ?s ?f)
           (son ?f ?g)))
#+END_SRC

if W is the wife of M, and S is the son of W, then S is the son of M 

#+BEGIN_SRC scheme
(rule (step-son ?m ?s)
      (and (wife ?w ?m)
           (son ?s ?w)))
#+END_SRC

** How the Query System Works 

This section gives an overview of the general structure of the system for the logical programming language, independent of low-level implementation details. 

The query evaluator must perform some kind of search in order to match queries against facts and rules in the database. One way to do this is with amb. Another possibility is to manage the search with the aid of streams, which this implementation will follow. Our query system is organized around two operations called pattern matching and unification. 

Pattern matching, together with the organization of information in terms of streams of frames, enables us to implement simple and complex queries. 

Unification is a generalization of pattern matching needed to implement rules. 

** Pattern Matching 

A pattern matcher is a program that tests whether some datum fits a specified pattern. The pattern matcher used by the query system takes as inputs a pattern, a datum, and a frame that specifies bindings for various pattern variables. It checks whether the datum matches the pattern in a way that is consistent with the bindings already in the frame. The pattern matcher is needed to process simple queries that don't involve rules. 

** Steams of Frames

Given a single frame, the matching process runs through the database entries one by one. For each entry, the matcher generates either a special symbol indicating that the match has failed or an extension to the frame. The results for all the database entries are collected into a stream, which is passed through a filter to weed out failures. The result is a stream of all the frames that extend the given frame via a match to some assertion in the database. 

In general, since pattern matching is an expensive operations, we wish to do this filtering in two passes: first a coarse filter, then a finer filter. Ideally we would do this at the creation time of the database, which is called indexing. 

To answer a simple query, we use the query with an input stream consisting of a single empty frame. The resulting output stream contains all extensions to the empty frame. The stream of frames is then used to generate a stream of copies of the original query pattern with the variables instantiated by the values in each frame, and this stream is then printed.

** Compound Queries 

The elegance of the stream-of-frames implementation is evident when we consider compound queries. We can think of these as series of filters performed by simple queries, i.e.,

#+BEGIN_SRC scheme
(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
#+END_SRC

is a simple query for can-do-job passed to the next query for job.

Similarly or is two streams that are then merged. Not is a stream that returns all the values that the pattern matcher would otherwise drop. 

** Unification

Rule conclusions are like assertions except that they contain variables, so we will need a generalization of pattern matching -- called unification -- in which both the pattern and the datum may contain variables. 

A unifier takes two patterns, each containing constants and variables, and determines whether it is possible to assign values to the variables that will make the two patterns equal. If so, it returns a frame containing these bindings. The unifier used in the query system, like the pattern matcher, take a frame as input and perform unifications that are consistent with this frame.

** Applying Rules 

Unification is the key to the component of the query system that makes inference from rules. 

In general, the query evaluator uses the following method to apply a rule when trying to establish a query pattern in a frame that specifies bindings for some of the pattern variables:

- Unify the query with the conclusion of the rule to form, if successful, an extension of the original frame
- Relative to the extended frame, evaluate the query formed by the body of the rule

Notice how similar this is for applying a procedure in the eval-apply evaluator for lisp: 

- Bind the procedure's parameters to its arguments to form a frame that extends the original procedure environment
- Relative to the extended environment, evaluate the expression formed by the body of the procedure

** Simple Queries 

Given the query pattern and a stream of frames, we produce, for each frame in the input stream, two streams: 

- a stream of extended frames obtained by matching the pattern against all assertions in the database (using the pattern matcher)
- a stream of extended frames obtains by applying all possible rules (using the unifier)

Since unification is a generalization of pattern matching, we could use the unifier for both steps, but this illustrates the usefulness of the pattern matcher in its own right. 

** Is Logic Programming Mathematical Logic? 

The operations and, or, not, and the application of query language rules is accomplished through a legitimate method of inference. This identification of the query language with mathematical logic is not really valid though because the query language provides a control structure that interprets the logic statements procedurally. 

The aim of logic programming is to provide the programmer with two techniques for decomposing a computational problem into two separate problems: "what" is to be computed, and "how" this should be computed. Control ("how" to compute) is effected by using the order of evaluation of the language. At the same time, we should be able to view the result of the computation ("what" to compute) as a simple consequence of the laws of logic. 

