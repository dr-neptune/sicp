* Formulating Abstractions with Higher Order Procedures
  :PROPERTIES:
  :header-args: :session scheme :results verbatim raw
  :END:

We will be severely limited in our ability to create abstractions if we are restricted to procedures whose parameters must be numbers. Often the same process will be used with a number of different procedures. To express such patterns as concepts, we will need to construct procedures that can accept procedures as arguments or return procedures as values.

Procedures that manipulate procedures are called higher-order procedures.


** Procedures as Arguments

 Compute the sum of the integers from a through b

 #+BEGIN_SRC scheme
(define (sum-integers a b)
  (if (> a b)
      0
      (+ a (sum-integers (+ a 1) b))))

(sum-integers 5 50)
 #+END_SRC

 #+RESULTS:
 1265

 Compute the sum of the cubes of the integers in the given range

 #+BEGIN_SRC scheme
(define (cube x)
  (* x x x))

(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a)
         (sum-cubes (+ a 1) b))))

(sum-cubes 5 50)
 #+END_SRC

 #+RESULTS:
 1625525
 1625525

 Compute the sum of a sequence of terms in the series

 1 / 1*3 + 1 / 5*7 + 1 / 9 * 11 + ...

 which converges to pi / 8 slowly

 #+BEGIN_SRC scheme
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))

(pi-sum 1 50)
 #+END_SRC

 #+RESULTS:
 .3878931641107514


 We could generate each of the procedures by filling in slots in the same template:

 #+BEGIN_SRC scheme
(define (<name> a b)
  (if (> a b)
      0
      (+ (<term> a)
         (<name> (<next> a) b))))
 #+END_SRC

 Mathematicians long ago identified the abstraction of summation of a series and invented sigma notation

 $\sum_{n = a}^b f(n) = f(a) + ... + f(b)$

 to express this concept. This allows us to formulate general results about sums that are independent of the particular series being summed.

 Similarly we wish to make procedures that deal with the concept itself rather than any specific sum. We do this by transforming the slots into formal parameters.

 #+BEGIN_SRC scheme
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
 #+END_SRC

 #+RESULTS:
 sum

 We can use sum just as we would any other procedure.

 For example, to define sum-cubes

 #+BEGIN_SRC scheme
(define (inc n) (+ n 1))

(define (sum-cubes a b)
  (sum cube a inc b))

(sum-cubes 1 10)
 #+END_SRC

 With the aid of an identity procedure to compute the term, we can define sum-integers in terms of sum

 #+BEGIN_SRC scheme
(define (identity x)
  x)

(define (sum-integers a b)
  (sum identity a inc b))

(sum-integers 1 10)
 #+END_SRC

 #+RESULTS:
 55
 55

 and pi-sum

 #+BEGIN_SRC scheme
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))

(* 8 (pi-sum 1 1000))
 #+END_SRC

 #+RESULTS:
 3.139592655589783

 Once we have sum, we can use it as a building block in formulating further concepts.

 For example, the definite integral of a function between the limits a and b can be approximated numerically using the formula

 $\int_a^b f = [f(a + \frac{dx}{2}) + 
                f(a + dx + \frac{dx}{2}) + 
                f(a + 2dx + \frac{dx}{2}) + ...]dx$

 for small values of dx. 

 We can express this directly as a procedure:

 #+BEGIN_SRC scheme
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))

(integral cube 0 1 0.001)
 #+END_SRC

 #+RESULTS:
 .249999875000001

 The exact value of the integral of cube between 0 and 1 is 1/4. 

*** Exercise 1.29

Simpson's Rule is a more accurate method of numerical integration than the method illustrated above. 

$\int_a^b f = \frac{h}{3}(y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + ... + 2y_{n-2} + 4y_{n-1} + y_n)$

where $h = \frac{(b - a)}{n}$ for some even integer n, and
$y_k = f(a + kh)$/ 

#+BEGIN_SRC scheme
(define (even? n)
  (= (remainder n 2) 0))

(define (inc x)
  (+ x 1))

(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
#+END_SRC

#+BEGIN_SRC scheme
(define (simpson-int f a b n)
  (define h (/ (- b a) n))
  (define (y k) (f (+ a (* k h))))
  (define (k-cond k)
    (* (cond ((or (= k 0) (= k n)) 1)
             ((even? k) 2)
             (else 4))
       (y k)))
  
  (* (sum k-cond a inc n)
     (/ h 3)))
#+END_SRC

#+RESULTS:
simpson-int

#+BEGIN_SRC scheme
(simpson-int cube 0 1 1000)
#+END_SRC

#+RESULTS:
1/4

*** Exercise 1.30

The sum procedure above generates a linear recursion. The procedure can be rewritten so that the sum is performed iteratively. 

#+BEGIN_SRC scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        0
        (+ (term result) (iter (next a) result)))))
#+END_SRC

#+RESULTS:
sum

#+BEGIN_SRC scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))
#+END_SRC

#+RESULTS:
sum

#+BEGIN_SRC scheme
(sum identity 0 inc 5)
#+END_SRC

*** Exercise 1.31 

The sum procedure is only the simplest of a number of similar abstractions that can be captured as higher order procedures. Write an analogous procedure called product that returns the product of the values of a function at points over a given range.

#+BEGIN_SRC scheme
(define (product term a next b)
  (if (> a b)
      1
      (* (term a)
         (product term (next a) next b))))
#+END_SRC

#+RESULTS:
product

#+BEGIN_SRC scheme
(define (cube x) (* x x x))

(product cube 1 inc 3)
#+END_SRC

#+RESULTS:
216

Show how to define factorial in terms of product

#+BEGIN_SRC scheme
(define (identity x) x)
#+END_SRC

#+RESULTS:
identity

#+BEGIN_SRC scheme
(define (factorial n)
  (product identity 1 inc n))
#+END_SRC

#+RESULTS:
factorial

#+BEGIN_SRC scheme
(factorial 5)
#+END_SRC

Also use product to compute approximations to pi using the formula

$\frac{\pi}{4} = \frac{2*4*4*6*6*8*...}{3*3*5*5*7*7*...}$

#+BEGIN_SRC scheme
(define (counter x)
  (if (even? x) (/ (+ x 2)
                   (+ x 1))
      (/ (+ x 1)
         (+ x 2))))
#+END_SRC

#+RESULTS:
counter

#+BEGIN_SRC scheme
(* 4.0 (product counter 1 inc 1000))
#+END_SRC

#+RESULTS:
3.1431607055322663

#+BEGIN_SRC scheme
(define (product-iter term a next b)
  (define (iter a prod)
    (if (> a b)
        prod
        (iter (next a) (* a prod))))
  (iter a 1))


#+END_SRC

#+BEGIN_SRC scheme
(product-iter identity 1 inc 5)
#+END_SRC

*** Exercise 1.32 

Show that sum and product are both special cases of a still more general notion called accumulate that combines a collection of terms, using some general accumulation function

#+BEGIN_SRC scheme
(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))
#+END_SRC

#+RESULTS:
accumulate

#+BEGIN_SRC scheme
(accumulate * 1 identity 1 inc 5)
#+END_SRC

#+RESULTS:
120

#+BEGIN_SRC scheme
(define (sum term a next b)
  (accumulate + 0 term a next b))

(sum identity 1 inc 5)
#+END_SRC

#+RESULTS:
15

#+BEGIN_SRC scheme
(define (product term a next b)
  (accumulate * 1 term a next b))

(product identity 1 inc 5)
#+END_SRC

#+RESULTS:
120

#+BEGIN_SRC scheme
(define (accumulate-iter combiner null-value term a next b)
  (define (iter a value)
    (if (> a b)
        (combiner value null-value)
        (iter (next a) (combiner value (term a)))))
  (iter a null-value))
#+END_SRC

#+RESULTS:
accumulate-iter


#+BEGIN_SRC scheme
(accumulate-iter + 0 identity 1 inc 5)
#+END_SRC

#+RESULTS:
15
120
 
*** Exercise 1.33
