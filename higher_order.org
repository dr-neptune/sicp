* Formulating Abstractions with Higher Order Procedures
  :PROPERTIES:
  :header-args: :session scheme :results verbatim raw
  :END:

We will be severely limited in our ability to create abstractions if we are restricted to procedures whose parameters must be numbers. Often the same process will be used with a number of different procedures. To express such patterns as concepts, we will need to construct procedures that can accept procedures as arguments or return procedures as values.

Procedures that manipulate procedures are called higher-order procedures.


** Procedures as Arguments

Compute the sum of the integers from a through b

#+BEGIN_SRC scheme
(define (sum-integers a b)
  (if (> a b)
      0
      (+ a (sum-integers (+ a 1) b))))

(sum-integers 5 50)
#+END_SRC

#+RESULTS:
1265

Compute the sum of the cubes of the integers in the given range

#+BEGIN_SRC scheme
(define (cube x)
  (* x x x))

(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a)
         (sum-cubes (+ a 1) b))))

(sum-cubes 5 50)
#+END_SRC

#+RESULTS:
1625525

Compute the sum of a sequence of terms in the series

1 / 1*3 + 1 / 5*7 + 1 / 9 * 11 + ...

which converges to pi / 8 slowly

#+BEGIN_SRC scheme
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))

(pi-sum 1 50)
#+END_SRC

#+RESULTS:
.3878931641107514


We could generate each of the procedures by filling in slots in the same template:

#+BEGIN_SRC scheme
(define (<name> a b)
  (if (> a b)
      0
      (+ (<term> a)
         (<name> (<next> a) b))))
#+END_SRC

Mathematicians long ago identified the abstraction of summation of a series and invented sigma notation

$\sum_{n = a}^b f(n) = f(a) + ... + f(b)$

to express this concept. This allows us to formulate general results about sums that are independent of the particular series being summed.

Similarly we wish to make procedures that deal with the concept itself rather than any specific sum. We do this by transforming the slots into formal parameters.

#+BEGIN_SRC scheme
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
#+END_SRC

We can use sum just as we would any other procedure.

For example, to define sum-cubes

#+BEGIN_SRC scheme
(define (inc n) (+ n 1))

(define (sum-cubes a b)
  (sum cube a inc b))

(sum-cubes 1 10)
#+END_SRC

With the aid of an identity procedure to compute the term, we can define sum-integers in terms of sum

#+BEGIN_SRC scheme
(define (identity x)
  x)

(define (sum-integers a b)
  (sum identity a inc b))

(sum-integers 1 10)
#+END_SRC

#+RESULTS:
55

and pi-sum

#+BEGIN_SRC scheme
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))

(* 8 (pi-sum 1 1000))
#+END_SRC

#+RESULTS:
3.139592655589783

Once we have sum, we can use it as a building block in formulating further concepts.

For example, the definite integral of a function between the limits a and b can be approximated numerically using the formula

$\int_a^b f = [f(a + \frac{dx}{2}) + 
               f(a + dx + \frac{dx}{2}) + 
               f(a + 2dx + \frac{dx}{2}) + ...]dx$

for small values of dx. 

We can express this directly as a procedure:

#+BEGIN_SRC scheme
(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))

(integral cube 0 1 0.001)
#+END_SRC

#+RESULTS:
.249999875000001

The exact value of the integral of cube between 0 and 1 is 1/4. 

*** Exercise 1.29

Simpson's Rule is a more accurate method of numerical integration than the method illustrated above. 

$\int_a^b f = \frac{h}{3}(y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + ... + 2y_{n-2} + 4y_{n-1} + y_n)$

where $h = \frac{(b - a)}{n}$ for some even integer n, and
$y_k = f(a + kh)$/ 

#+BEGIN_SRC scheme
(define (even? n)
  (= (remainder n 2) 0))

(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
#+END_SRC

#+BEGIN_SRC scheme
(define (simpsons-rule f a b n)
  (define h (/ (- b a) n))

  (define (k-term k)
    (cond ((= k 0) 1.0)
          ((= k n) 1.0)
          ((even? k) 2.0)
          (else 4.0)))
  
  (define (y k)
    (+ a (* (k-term k) h)))
  
  (* (sum f (y n) inc n) (/ h 3.0)))
#+END_SRC

#+BEGIN_SRC scheme
(simpsons-rule cube 0 1.0 3)
#+END_SRC
