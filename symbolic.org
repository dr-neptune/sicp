* Symbolic Data 
:PROPERTIES:
:header-args: :session scheme :results value
:END:

In this section we extend the representational capability of our language by introducing the ability to work with arbitrary symbols as data. 

** Quotation 

In order to manipulate symbols we need a new element in our language: the ability to quote a data object.

#+BEGIN_SRC scheme
(define a 1)
(define b 2)

(list a b)
(list 'a 'b)
(list 'a b)
#+END_SRC

#+RESULTS:

Quotation also allows us to type in compound objects, using the conventional printed representation for lists 

#+BEGIN_SRC scheme
(car '(a b c))
(cdr '(a b c))
#+END_SRC

#+RESULTS:
| b | c |

eq? takes two symbols as arguments and test whether they are the same. With this we can implement memq, which takes two args: a symbol and a list. If the symbol is not contained in the list, then memq returns false, otherwise it returns the sublist beginning with the first occurrence of the symbol 

#+BEGIN_SRC scheme
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))

(memq 'apple '(pear banana prune))
(memq 'apple '(x (apple sauce) y apple pear))
#+END_SRC

#+RESULTS:

*** Exercise 2.54 

#+BEGIN_SRC scheme
(define (equal? list1 list2)
  (cond ((null? list1) #t)
        ((eq? (car list1)
              (car list2))
         (equal? (cdr list1)
                 (cdr list2)))
        (else #f)))

(equal? '(this is a list)
        '(this (is a) list))
#+END_SRC

#+RESULTS:
: #f

*** Exercise 2.55 

#+BEGIN_SRC scheme
(car ''abracadabra)
#+END_SRC

#+RESULTS:
: quote

Eva is passing car a list of symbolic objects, ' and 'abracadabra. We see this by asking for the cdr and getting back abracadabra

#+BEGIN_SRC scheme
(cdr ''abracadabra)
#+END_SRC

#+RESULTS:
| abracadabra |

** Example: Symbolic Differentiation 

Consider the design of a procedure that performs symbolic differentiation of algebraic expressions. 

*** The differentiation program with abstract data 


#+BEGIN_SRC scheme
(define (variable? e))

(define (same-variable? v1 v2))

(define (sum? e))

(define (addend e))

(define (augend e))

(define (make-sum a1 a2))

(define (product? e))

(define (multiplier e))

(define (multiplicand e))

(define (make-product m1 m2))
#+END_SRC

#+RESULTS:

Using these primitives, we can write the rules for differentiation as follows:

#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product
           (multiplier exp)
           (deriv (multiplicand exp) var))
          (make-product
           (deriv (multiplier exp) var)
           (multiplicand exp))))
        (else (error "Unknown expression type: DERIV" exp))))
#+END_SRC

#+RESULTS:
: deriv


This procedure incorporates the complete differentiation algorithm. Since it is expressed in terms of abstract data, it will work no matter how we choose to represent algebraic expressions, as long as we design a proper set of selectors and constructors. 

*** Representing algebraic expressions 

Our data representation is the following: 

- The variables are symbols 

#+BEGIN_SRC scheme
(define (variable? x) (symbol? x))
#+END_SRC

#+RESULTS:
: variable?

- Two variables are the same if the symbols representing them are eq?

#+BEGIN_SRC scheme
(define (same-variable? v1 v2)
  (and (variable? v1)
       (variable? v2)
       (eq? v1 v2)))
#+END_SRC 

#+RESULTS:
: same-variable?

- Sums and products are constructed as lists 

#+BEGIN_SRC scheme
(define (make-sum a1 a2)
  (list '+ a1 a2))

(define (make-product m1 m2)
  (list '* m1 m2))
#+END_SRC

#+RESULTS:
: make-product

- A sum is a list whose first element is the symbol +

#+BEGIN_SRC scheme
(define (sum? x)
  (and (pair? x)
       (eq? (car x) '+)))
#+END_SRC

#+RESULTS:
: sum?

- The addend is the second item of the sum of the list 

#+BEGIN_SRC scheme
(define (addend s)
  (cadr s))
#+END_SRC

#+RESULTS:
: addend

- The augment is the third item of the sum of the list 

#+BEGIN_SRC scheme
(define (augend s)
  (caddr s))
#+END_SRC

#+RESULTS:
: augend

- and similarly for multiplication 

#+BEGIN_SRC scheme
(define (product? x)
  (and (pair? x)
       (eq? (car x) '*)))

(define (multiplier p)
  (cadr p))

(define (multiplicand p)
  (caddr p))
#+END_SRC

#+RESULTS:
: multiplicand

We should now have a fully working deriv function 

#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y)
           (+ x 3))
       'x)
#+END_SRC

#+RESULTS:
| + | (* (* x y) (+ 1 0)) | (* (+ (* x 0) (* 1 y)) (+ x 3)) |

This is correct, but the program doesn't manage to simplify the result of the expression. We can accomplish the needed reduction without modifying the higher level function, but instead changing the constructors and selectors. 

#+BEGIN_SRC scheme
(define (=number? exp num)
  (and (number? exp)
       (= exp num)))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1)
              (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0)
             (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1)
              (number? m2))
         (* m1 m2))
        (else (list '* m1 m2))))
#+END_SRC

#+RESULTS:
: make-product

#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y)
           (+ x 3))
       'x)
#+END_SRC

#+RESULTS:
| + | (* x y) | (* y (+ x 3)) |

The problem of algebraic simplification is complex because a form that may be simplest for one purpose may not be for another 

*** Exercise 2.56 

#+BEGIN_SRC scheme
(define (exponentiation? x)
  (and (pair? x)
       (eq? (car x)
          '**)))

(define (base x)
  (cadr x))

(define (exponent x)
  (caddr x))

(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        (else (list '** base exponent))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product
           (multiplier exp)
           (deriv (multiplicand exp) var))
          (make-product
           (deriv (multiplier exp) var)
           (multiplicand exp))))
        ((exponentiation? exp)
          (make-product
           (exponent exp)
           (make-product
            (make-exponentiation
             (base exp)
             (- (exponent exp) 1))
            (deriv (base exp) var))))
        (else (error "Unknown expression type: DERIV" exp))))

(deriv '(** x 5) 'x)
#+END_SRC

#+RESULTS:
| 5 | (** x 4) |

*** Exercise 2.57 

Extend the differentiation program to handle sums and products of arbitrary numbers of two or more terms by only changing the representation of sums and products. 

#+BEGIN_SRC scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (augend s)
  (accumulate make-sum 0 (cddr s)))

(define (multiplicand p)
  (accumulate make-product 1 (cddr p)))
#+END_SRC

#+RESULTS:
: multiplicand


#+BEGIN_SRC scheme
(deriv '(* x y (+ x 3)) 'x)
#+END_SRC

*** Exercise 2.58 

Solution stolen from schemewiki -- This is vpraid's modified shunting yard algorithm (by Dijkstra): 

https://en.wikipedia.org/wiki/Shunting-yard_algorithm


Pseudocode: 

1.  While there are tokens to be read:
2.        Read a token
3.        If it's a number add it to queue
4.        If it's an operator
5.               While there's an operator on the top of the stack with greater precedence:
6.                       Pop operators from the stack onto the output queue
7.               Push the current operator onto the stack
8.        If it's a left bracket push it onto the stack
9.        If it's a right bracket 
10.            While there's not a left bracket at the top of the stack:
11.                     Pop operators from the stack onto the output queue.
12.             Pop the left bracket from the stack and discard it
13. While there are operators on the stack, pop them to the queue

- So for step 2 and 3 we need a number? and operator? function 

- For the rest of the steps we need a stack implementation (can be done with lists) and to create left and right stacks for the numbers and operators 

- This procedure gives us reverse polish notation, when we really want prefix notation. In order to account for this, we need to make sure that operators are popped before numbers 


#+BEGIN_SRC scheme
(define (make-difference a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1)
              (number? a2))
         (- a1 a2))
        (else (list '- a1 a2))))

(define (op? o)
  (or (eq? o '+)
      (eq? o '-)
      (eq? o '*)
      (eq? o '**)))
  
(define (precedence o) 
  (cond ((eq? o '+) 1) 
        ((eq? o '-) 1) 
        ((eq? o '*) 2) 
        ((eq? o '**) 3) 
        (else (error "unknown operator: PRECEDENCE" o)))) 
  
(define (associativity o) 
  (cond ((eq? o '+) 'left) 
        ((eq? o '-) 'left) 
        ((eq? o '*) 'left) 
        ((eq? o '**) 'right) 
        (else (error "unknown operator: ASSOCIATIVITY" o)))) 
  
(define (shunting-yard exp) 
  (define (apply-op output op) 
    (let ((lhs (cadr output)) 
          (rhs (car output))) 
      (cons
       (cond ((eq? op '+) (make-sum lhs rhs)) 
             ((eq? op '-) (make-difference lhs rhs)) 
             ((eq? op '*) (make-product lhs rhs)) 
             ((eq? op '**) (make-exponentiation lhs rhs)) 
             (else error "unknown operator: APPLY-OP" op)) 
       (cddr output)))) 

  (define (iter output operators exp)
    (if (null? exp) 
        (if (null? operators) ; pushing whatever is left in op stack into output 
            (car output) 
            (iter (apply-op output (car operators))
                  (cdr operators) exp)) 
        (let ((token (car exp)))
          (cond ((list? token)     ; pushing sublist into output 
                 (iter (cons (shunting-yard token) output) operators (cdr exp))) 
                ((op? token) ; pushing new operation into output or op stack 
                 (if (and (not (null? operators))
                          (or (and (eq? (associativity token) 'left)
                                   (<= (precedence token)
                                       (precedence (car operators))))
                              (and (eq? (associativity token) 'right)
                                   (< (precedence token) 
                                      (precedence (car operators)))))) 
                     (iter (apply-op output (car operators))
                           (cdr operators)
                           exp)
                     (iter output
                           (cons token operators)
                           (cdr exp)))) 
                (else ; pushing new number or variable into output 
                 (iter (cons token output)
                       operators
                       (cdr exp))))))) 
  (iter '() '() exp))
#+END_SRC


#+BEGIN_SRC scheme
(shunting-yard '(x * y (x + 3)))
#+END_SRC

#+BEGIN_SRC scheme
(define (deriv-infix exp var)
  (deriv (shunting-yard exp) var))
#+END_SRC

#+RESULTS:
: deriv-infix

#+BEGIN_SRC scheme
(deriv '(* x y (+ x 3)) 'x)
#+END_SRC

#+RESULTS:
| + | (* x y) | (* y (+ x 3)) |

#+BEGIN_SRC scheme
(deriv-infix '(x * y (x + 3)) 'x)
(deriv-infix '(x + 3 * (x + y + 2)) 'y)
#+END_SRC

#+RESULTS:
: 3

** Example: Representing Sets 

Thus far we have built representations for two kinds of compound data objects: rational numbers and algebraic expressions. In one we had the choice of simplifying the expressions at either construction time or selection time. 

When we turn to the representation of sets, the choice of representation is not so obvious. 

Informally, a set is simply a collection of distinct objects. To give a more precise definition, we can employ the method of data abstraction and define sets by specifying the operations that are to be used on sets. 

These are: 

- union-set
- intersection-set
- element-of-set?
- adjoin-set

From the viewpoint of data abstraction, we are free to design any representation that implements these operations in a way consistent with the interpretations given above. 

** Sets as unordered lists 

#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond ((or (null? set1)
             (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
#+END_SRC

- element-of-set is O(n)
- adjoin-set is O(n)
- intersection-set has to check for each element of each set, so it could be O(n^2)

*** Exercise 2.59 

Implement the union-set operation for the unordered-list representation of sets 

#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (cond ((and (null? set1)
              (null? set2)) '())
        ((null? set1) set2)
        ((null? set2) set1)
        ((not (element-of-set? (car set1) set2))
         (cons (car set1)
               (union-set (cdr set1) set2)))
        (else (union-set (cdr set1) set2))))

(union-set '(1 2 3 4) '(2 3 4 5))
(union-set '(1 2 3) '(1 2 3))
#+END_SRC

*** Exercise 2.60 

Suppose we allow duplicates. Design procedures that operate on this representation. 

#+BEGIN_SRC scheme
(define (element-of-set-dups? x set)
  (element-of-set? x set))

(define (adjoin-set-dups x set)
  (cons x set))

(define (drop-first x set)
  (if (equal? x (car set))
      (cdr set)
      (cons (car set)
            (drop-first x (cdr set)))))

(define (intersection-set-dups set1 set2)
  (cond ((or (null? set1)
             (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons
          (car set1)
          (intersection-set-dups (cdr set1)
                                 (drop-first
                                  (car set1) set2))))
        (else (intersection-set-dups (cdr set1) set2))))

(intersection-set-dups '(1 2 3 3 3 4 4 4 4) '(2 2 3 3 4 4 5))

(define (union-set-dups set1 set2)
  (append set1 set2))

(union-set-dups '(1 2 2 3 3 4 4) '(1 2 2 2 3 3 3 4 4 4))
#+END_SRC

How does the efficiency of each compare with the corresponding procedure for the non-duplicate representation? 

- element of set is the same, O(n)
- adjoin-set is constant time O(1)
- union-set with cons is constant time, with append it traverses the first set so O(n)
- intersection-set is O(n^2)


Are there applications for which you would use this representation in preference to the non-duplicate one? 

For applications in which we would expect to be mostly performing unions and adjoins as opposed to intersections. Also since this repeated set is such a normal thing, its just an unconstrained data structure. We would only need the regular set functions when we want that exact uniqueness constraint. 

** Sets as ordered lists 

One way to speed up our set operations is to change the representation so that the set elements are listed in increasing order. 

An advantage or ordering shows up in element-of-set?: In checking for the presence of an item, we no longer have to scan the entire set. 

#+BEGIN_SRC scheme
(define (element-of-set-ordered? x set)
  (cond ((null? set) #f)
        ((= x (car set)) #t)
        ((< x (car set)) #f)
        (else (element-of-set-ordered? x (cdr set)))))

(element-of-set-ordered? 4 '(1 2 3 4 5 6))
#+END_SRC

We obtain a more impressive speed-up with intersection-set. 

- Compare the elements x1 and x2 of the first two sets. If x1 == x2, then that gives an element of the intersection and we can return that element and the cdrs of the two sets.
- If x1 < x2, since x2 is the smallest element of set2 we can drop x1.

#+BEGIN_SRC scheme
(define (intersection-set-o set1 set2)
  (if (or (null? set1)
          (null? set2))
      '()
      (let ((x1 (car set1))
            (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (intersection-set-o (cdr set1)
                                         (cdr set2))))
              ((< x1 x2)
               (intersection-set-o (cdr set1) set2))
              ((< x2 x1)
               (intersection-set-o set1 (cdr set2)))))))

(intersection-set-o '(1 2 4 6 7 8 9) '(2 3 4 6 8 10))
#+END_SRC

Observe that at each step we reduce the intersection problem to computing intersections of smaller sets. Thus, the number of steps required is at most the sum of the sizes of set1 and set2, rather than the product of sizes as with the unordered representation. This is O(n + m) = O(n) growth rather than O(n^2).

*** Exercise 2.61

Give an implementation of adjoin-set using the ordered representation.

#+BEGIN_SRC scheme
(define (adjoined-set-o x set)
  (cond ((null? set) x)
        ((= x (car set)) set)
        ((> x (car set))
         (cons (car set)
               (adjoined-set-o x (cdr set))))
        (else (cons x (cdr set)))))

(adjoin-set-o 5 '(1 2 3 4 6 7 8))
#+END_SRC

*** Exercise 2.62 

Give an O(n) implementation of union-set for sets represented as ordered lists. 

- check if car s1 = car s2 
  if yes, cons s1 and move both forward 
- check if car s1 < car s2 
  if yes, cons it 
  if no, cons car s2 and move both forward 

#+BEGIN_SRC scheme
(define (union-set-o set1 set2)
  (cond ((and (null? set1)
              (null? set2))
         '())
        ((null? set1) set2)
        ((null? set2) set1)
        ((= (car set1) (car set2))
         (cons (car set1)
               (union-set-o (cdr set1) (cdr set2))))
        ((< (car set1) (car set2))
         (cons (car set1)
               (union-set-o (cdr set1) set2)))
        (else (cons (car set2)
                    (union-set-o set1 (cdr set2))))))

(union-set-o '(1 3 5 7) '(0 2 4 6 8))
#+END_SRC

** Sets as Binary Trees 

We can do better than ordered list representation by arranging the set elements in the form of a tree. The only thing that we require for a valid representation is that all the elements in the left subtree be smaller than the node entry and all the entries in the right subtree be larger. 

We can represent trees by using lists. Each node will be a list of three items:

- The entry at the node
- The left subtree
- The right subtree

A left or a right subtree of the empty list will indicate that there is no subtree connected there. 

#+BEGIN_SRC scheme
(define (entry tree)
  (car tree))

(define (left-branch tree)
  (cadr tree))

(define (right-branch tree)
  (caddr tree))

(define (make-tree entry left right)
  (list entry left right))
#+END_SRC

We are representing sets in terms of trees, and trees in terms of lists -- in effect, a data abstraction built upon a data abstraction. 


#+BEGIN_SRC scheme
(define (element-of-set-t? x set)
  (cond ((null? set) #f)
        ((= x (entry set)) #t)
        ((< x (entry set))
         (element-of-set-t? x (left-branch set)))
        (else (element-of-set-t? x (right-branch set)))))
#+END_SRC

Adjoining an element to a set is implemented similarly. 

#+BEGIN_SRC scheme
(define (adjoin-set-t x set)
  (cond ((null? set)
         (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set)
                    (adjoin-set-t x (left-branch set))
                    (right-branch set)))
        (else
         (make-tree (entry set)
                    (left-branch set)
                    (adjoin-set-t x (right-branch set))))))
#+END_SRC

The claim that searching the tree can be performed in a logarithmic number of steps rests on the assumption that the tree is balanced. 

We can't be certain that a tree is balanced, and even if it were, we can't guarantee that it will stay balanced according to its current definition. 

We need to define a procedure that will take all the elements of the current tree and rebalance them. Then we could perform this transformation after every few adjoin-set operations to keep the set in balance. 

*** Exercise 2.63

Each of the following two procedures converts a binary tree to a list. 

#+BEGIN_SRC scheme
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list
                             (right-branch tree)
                             result-list)))))
  (copy-to-list tree '()))
#+END_SRC

a. Do the two procedures produce the same result for every tree? If not how do the results differ? What lists do the two procedures produce for the trees in figure 2.16?

#+BEGIN_SRC scheme :results output
(define ex-tree-1 (make-tree 7 (make-tree 3
                                          (make-tree 1 '() '())
                                          (make-tree 5 '() '()))
                             (make-tree 9
                                        '()
                                        (make-tree 11 '() '()))))

(define ex-tree-2 (make-tree 3
                             (make-tree 1 '() '())
                             (make-tree 7
                                        (make-tree 5 '() '())
                                        (make-tree 9
                                                   '()
                                                   (make-tree 11 '() '())))))

(define ex-tree-3 (make-tree 5 (make-tree 3
                                          (make-tree 1 '() '())
                                          '())
                             (make-tree 9
                                        (make-tree 7 '() '())
                                        (make-tree 11 '() '()))))
#+END_SRC

#+BEGIN_SRC scheme
(tree->list-1 ex-tree-1)
(tree->list-2 ex-tree-1)

(tree->list-1 ex-tree-2)
(tree->list-2 ex-tree-2)

(tree->list-1 ex-tree-3)
(tree->list-2 ex-tree-3)
#+END_SRC

The trees are all consistent across both algorithms. 

b. Do the two procedures have the same order of growth in the number of steps required to convert a balanced tree with n elements to a list? If not, which one grows more slowly? 

Looking back at the definitions 

#+BEGIN_SRC scheme
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list
                             (right-branch tree)
                             result-list)))))
  (copy-to-list tree '()))
#+END_SRC

For tree->list1: 

- append is O(n), but given that we are looking at balanced binary trees, we should see O(n/2) + O((n - 1)/2*2) + O((n - 2)/2*2*2).
- Cons is constant time O(1)
- The time complexity of this algorithm is O(nlogn)

For tree->list2: 

- At each step, only a cons is performed
- The time complexity of this algorithm is O(n)

*** Exercise 2.64 

The following procedure list->tree converts an ordered list to a balanced binary tree. The helper procedure partial-tree takes as arguments an integer n and a list of at least n elements and constructs a balanced tree containing the first n elements of the list. 

The result returned by partial-tree is a pair (formed with cons) whose car is the constructed tree and whose cdr is the list of elements not included in the tree. 

#+BEGIN_SRC scheme
(define (list->tree elements)
  (car (partial-tree
        elements (length elements))))

(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts) right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))

(list->tree '(1 3 5 7 9 11))
#+END_SRC

1. Explain as clearly as possible how partial-tree works. Draw the tree produced by list->tree for the list (1 3 5 7 9 11)

#+BEGIN_SRC scheme
(define (partial-tree elts n)
  ; return empty tree for constructed tree and everything else for not included
  (if (= n 0)
      (cons '() elts)
      ; split up sizes 50/50 amongst n chosen elements
      (let ((left-size (quotient (- n 1) 2)))
        ; rerun the algo on just the left side
        (let ((left-result (partial-tree elts left-size)))
          ; pull first element of left tree
          (let ((left-tree (car left-result))
                ; look at rest of left tree
                (non-left-elts (cdr left-result))
                ; get size for the right tree based on left size
                (right-size (- n (+ left-size 1))))
            ; look at first element of right tree
            (let ((this-entry (car non-left-elts))
                  ; run algo on right tree 
                  (right-result (partial-tree (cdr non-left-elts) right-size)))
              ; get first element of right tree 
              (let ((right-tree (car right-result))
                    ; get rest of elements of right tree
                    (remaining-elts (cdr right-result)))
                ; make a tree of the first entry for the center, left and right
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      ; recurse on the tree. 
                      ; rem-elts -> cdr right-result -> partial-tree
                      remaining-elts))))))))
#+END_SRC

2. What is the order of growth in the number of steps required by list->tree to convert a list of n elements? 

At each step we are splitting the set into middle, left and right trees. Each of the procedures called in this are constant time. Since we visit each node in turn, we have $sum_{i = 1}^n O(1) = O(n)$

*** Exercise 2.65 

Use the results of 2.63 and 2.64 to give O(n) implementations of union-set and intersection-set for sets implemented as balanced binary trees.

#+BEGIN_SRC scheme
(define (union-set-t set1 set2)
  (cond ((and (null? set1)
              (null? set2)) '())
        ((null? set1) set2)
        ((null? set2) set1)
        (else (list->tree (union-set-o (tree->list-2 set1)
                                       (tree->list-2 set2))))))

(define set-tree-1 (list->tree '(1 2 3 4 5)))
(define set-tree-2 (list->tree '(2 3 4 5 6)))

(union-set-t set-tree-1 set-tree-2)

(define (intersection-set-t set1 set2)
  (cond ((and (null? set1)
              (null? set2)) '())
        ((null? set1) set2)
        ((null? set2) set1)
        (else (list->tree (intersection-set-o (tree->list-2 set1)
                                              (tree->list-2 set2))))))

(intersection-set-t set-tree-1 set-tree-2)
#+END_SRC

** Sets and Information Retrieval 

The techniques discussed here appear again and again in applications involving information retrieval. 

Suppose we have a database and we represent it as a set of records. If the set of records is implemented as an unordered list, we could use 

#+BEGIN_SRC scheme
(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) #f)
        ((equal? given-key
                 (key (car set-of-records)))
         (car set-of-records))
        (else
         (lookup given-key
                 (cdr set-of-records)))))
#+END_SRC

*** Exercise 2.66

Implement the lookup procedure for the case where the set of records is structured as a binary tree, ordered by the numerial values of the keys. 

#+BEGIN_SRC scheme
(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) #f)
        ((= given-key
            (key (entry set-of-records)))
         (car set-of-recordrs))
        ((< given-key
            (key (entry set-of-records)))
         (lookup given-key (left-branch set-of-records)))
        (else (lookup given-key (right-branch set-of-records))))
#+END_SRC

** Example: Huffman Encoding Trees

This section provides practice in the use of list structure and data abstraction to manipulate sets and trees. The application is to methods for representing data as sequences of ones and zeros (bits). 

Codes such as ASCII and the A-through-H code described in the book are known as fixed-length codes, because they represent each symbol in the message with the same number of bits. 

It is sometimes advantageous to use variable-length codes, in which different symbols may be represented by using different numbers of bits. A good example of this is morse code. 

In general, if our messages are such that some symbols appear very frequently and some very rarely, we can encode data more efficiently.

Another solution is to design a code in such a way that no complete code for any symbol is the beginning (or prefix) of the code for another symbol. Such a code is called a prefix code. 

In general, we can attain significant savings if we use *variable-length prefix* codes that take advantage of the relative frequencies of the symbols in the messages to be encoded. 

One scheme for this is the Huffman encoding method. A Huffman code can be represented as a binary tree whose leaves are symbols that are encoded. At each non-left node of the tree there is a set containing all the symbols which are contained in the leaves below the node. In addition, each symbol at a leaf is assigned a weight (which is its relative frequency), and each non-leaf node contains a weight that is the sum of all weights of the leaves lying below it. 

Given a Huffman tree, we can find the encoding of any symbol by starting at the root and moving down until we reach a leaf that holds the symbol. Each time we move down a left branch we add a 0 to the code, and each time we go down a right branch we add a 1. 

*** Generating Huffman Trees 

Given an alphabet of symbols and their relative frequencies, how do we construct the best code? 

The algorithm for generating a Huffman tree is very simple. The idea is to arrange the tree s.t. the symbols with the lowest frequency appear farthest away from the root. 

Begin with a set of leaf nodes, containing symbols and their frequencies, as determined by the initial data from which the code is to be constructed. 

Now find two leaves with the lowest weights and merge them to produce a node that has these two nodes as its left and right branches. The weight of the new node is the sum of the two weights. 

Remove the two leaves from the original set and replace them by this new node. Now continue this process, until there is only one node left which is the root of the entire tree. 

Initial Leaves
{(A 8)(B 3)(C 1)(D 1)(E 1)(F 1)(G 1)(H 1)}

Merge
{(A 8)(B 3)({C D} 2)(E 1)(F 1)(G 1)(H 1)}

Merge
{(A 8)(B 3)({C D} 2)({E F} 2)(G 1)(H 1)}

Merge
{(A 8)(B 3)({C D} 2)({E F} 2)({G H} 2)}

Merge
{(A 8)(B 3)({C D} 2)({E F} 2)({G H} 2)}

Merge
{(A 8)(B 3)({C D} 2)({E F G H} 4)}

Merge
{(A 8)({B C D} 5)({E F G H} 4)}

Merge
{(A 8)({B C D E F G H} 9)}

Merge
{({A B C D E F G H} 17)}

The algorithm does not always specify a unique tree, because there may not be a unique smallest weight node at each step. Also the choice of the order in which the two nodes are merged is arbitrary. 

*** Representing Huffman Trees

Leaves of the tree are represented by a list consisting of the symbol leaf, the symbol at the leaf, and the weight. 

#+BEGIN_SRC scheme
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf leaf)
  (cadr leaf))

(define (weight-leaf leaf)
  (caddr leaf))
#+END_SRC

A general tree will be 

- a list of a left branch
- a right branch
- a set of symbols
- a weight 
- The set of symbols will be a list of the symbols rather than some sophisticated set representation

When we make a tree by merging two modes, we obtain the weight of the tree as the sum of the weight of the nodes, and the set of symbols as the union of the sets of symbols for the nodes. 

#+BEGIN_SRC scheme
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left)
                (symbols right))
        (+ (weight left)
           (weight right))))

(define (left-branch tree)
  (car tree))

(define (right-branch tree)
  (cadr tree))

(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
#+END_SRC

symbols and weight are examples of generic procedures (procedures that can handle more than one kind of data). 

*** Decoding Procedure

The decoding procedure takes as arguments zeros and ones, together with a Huffman tree. 

The procedure decode-1 takes two arguments: the list of remaining bits and the current position in the tree. It keeps moving down the tree, choosing a left or a right branch according to whether the next bit in the list is a zero or one (this is done with choose-branch).

When it reaches a leaf, it returns a symbol at that leaf as well as the next symbol in the message by consing it onto the result of decoding the rest of the message, starting at the root of the tree. 

#+BEGIN_SRC scheme
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit: CHOOSE-BRANCH" bit))))

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch
                (car bits)
                current-branch)))
          (if (leaf? next-branch)
              (cons
               (symbol-leaf next-branch)
               (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits)
                        next-branch)))))
  (decode-1 bits tree))
#+END_SRC

*** Sets of weighted elements 

The tree-generating algorithm requires that we work with sets of leaves and trees, successively merging the two smallest items. Since we will be required to repeatedly find the smallest item in a set, it is convenient to use an ordered representation for this kind of set. 

We will represent a set of leaves and trees as a list of elements, arranged in increasing order of weight. 

#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x)
            (weight (car set)))
         (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
#+END_SRC

The following procedure takes a list of symbol frequency pairs such as ((a 4)(b 2)(c 1)(d 1)) and constructs an initial ordered set of leaves, ready to be merged according to the Huffman algorithm.

#+BEGIN_SRC scheme
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set
         (make-leaf (car pair)
                    (cadr pair))
         (make-leaf-set (cdr pairs))))))
#+END_SRC

*** Exercise 2.67 

Define an encoding tree and a sample message 

#+BEGIN_SRC scheme
(define sample-tree
  (make-code-tree
   (make-leaf 'A 4)
   (make-code-tree
    (make-leaf 'B 2)
    (make-code-tree
     (make-leaf 'D 1)
     (make-leaf 'C 1)))))

(define sample-message
  '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+END_SRC

Use the decode procedure to decode the message and give the result 

#+BEGIN_SRC scheme :results org
(decode sample-message sample-tree)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
(a d a b b c a)
#+END_SRC

*** Exercise 2.68 

The encode procedure takes as arguments a message and a tree and produces the list of bits that gives the encoded message. 

#+BEGIN_SRC scheme
(define (encode message tree)
  (if (null? message)
      '()
      (append
       (encode-symbol (car message) tree)
       (encode (cdr message) tree))))
#+END_SRC

encode-symbol is a procedure that returns the list of bits that encode a given symbol according to a given tree. 

You should design encode-symbol so that it signals an error if the symbol is not in the tree at all. Test the procedure by encoding the result obtained in 2.67. 

Check if the node is the first symbol
if yes, cons it to the list and return the cdr of the message 
if no, check the left right right trees and cons a 0 and 1 to each of the calls.

Check is the symbol is contained in the subtree 
If so, is it contained in a leaf? if so return 0 or 1 depending on left or right
If not, check if its contained in left or right tree. If yes, recurse on the correct side and cons a 0 or a 1. If not contained, throw an error. 

#+BEGIN_SRC scheme
(define (encode-symbol symbol tree)
  (let ((contained-in?
         (lambda (symbol tree)
           (memq symbol (caddr tree)))))
    (if (contained-in? symbol tree)
        (cond ((eq? symbol (symbol-leaf (left-branch tree))) '(0))
              ((eq? symbol (symbol-leaf (right-branch tree))) '(1))
              ((contained-in? symbol (right-branch tree))
               (cons 1 (encode-symbol symbol (right-branch tree))))
              (else
               (cons 0 (encode-symbol symbol (left-branch tree)))))
        (error "Symbol not found on tree"))))

(define test-encoding (encode '(a d a b b c a) sample-tree))
(equal? test-encoding sample-message)
#+END_SRC

*** Exercise 2.69

Since we are assuming that we have an ordered set representation, we can use accumulate 

#+BEGIN_SRC scheme
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successive-merge pairs)
  (accumulate make-code-tree (car pairs) (cdr pairs)))

(define ex-tree-gen (generate-huffman-tree '((A 4) (B 2) (D 1) (C 1))))

(encode '(A C B D) ex-tree-gen)
(decode '(1 1 0 1 1 1 1 0 0) ex-tree-gen)
#+END_SRC


*** Exercise 2.70

#+BEGIN_SRC scheme
(define rock-tree (generate-huffman-tree '((A 2)
                                           (NA 16)
                                           (BOOM 1)
                                           (SHA 3)
                                           (GET 2)
                                           (YIP 9)
                                           (JOB 2)
                                           (WAH 1))))
(rock-tree)
(encode '(get a job sha na na na na na na na na get a job sha na na na na na na na na wah yip yip yip yip yip yip yip yip yip sha boom) rock-tree)
#+END_SRC

#+RESULTS:
| 1 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |

208 bits are needed to encode it. 

If we used a fixed length code, we would need to have 3 bits per word, since there are 8 total words. So we would have 3 * num words = 3 * 36 = 108 bits 

*** Exercise 2.71 

'((a 1)(b 2)(c 4)(d 8)(e 16))

                (a b c d e) 31
            (a b c d) 15    (e) 16
        (a b c) 7    (d) 8
    (a b) 3    (c) 4
(a) 1    (b) 2


In such a tree, how many bits are required to encode the most frequent symbol? The least?

Since we are encoding this tree in binary, we would need 1,2,3,4,...,2^n bits for our symbols. 

*** Exercise 2.72 

#+BEGIN_SRC scheme
(define (encode-symbol symbol tree)
  (let ((contained-in?
         (lambda (symbol tree)
           (memq symbol (caddr tree)))))
    (if (contained-in? symbol tree)
        (cond ((eq? symbol (symbol-leaf (left-branch tree))) '(0))
              ((eq? symbol (symbol-leaf (right-branch tree))) '(1))
              ((contained-in? symbol (right-branch tree))
               (cons 1 (encode-symbol symbol (right-branch tree))))
              (else
               (cons 0 (encode-symbol symbol (left-branch tree)))))
        (error "Symbol not found on tree"))))
#+END_SRC

What is the order of growth in the number of steps to encode a symbol?

We need to check if the symbol is at the particular node. Each occurrence of this is O(m) since we need to check a list of m elements. Then we need to logarithmically move down the tree. Suppose we have a list that is n elements deep. Then we are looking at 

O(m log n)

If the relative frequencies are as described in 2.71, we end up with a long list scenario. In this case, we are checking the symbol list at each level, for O(m) steps. Then we are not actually logarithmically splitting the tree, so we will have the entire n nodes of the tree. Thus we get 

O(mn)


