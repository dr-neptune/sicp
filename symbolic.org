* Symbolic Data 
:PROPERTIES:
:header-args: :session scheme :results value
:END:

In this section we extend the representational capability of our language by introducing the ability to work with arbitrary symbols as data. 

** Quotation 

In order to manipulate symbols we need a new element in our language: the ability to quote a data object.

#+BEGIN_SRC scheme
(define a 1)
(define b 2)

(list a b)
(list 'a 'b)
(list 'a b)
#+END_SRC

#+RESULTS:
| a | 2 |

Quotation also allows us to type in compound objects, using the conventional printed representation for lists 

#+BEGIN_SRC scheme
(car '(a b c))
(cdr '(a b c))
#+END_SRC

#+RESULTS:
| b | c |

eq? takes two symbols as arguments and test whether they are the same. With this we can implement memq, which takes two args: a symbol and a list. If the symbol is not contained in the list, then memq returns false, otherwise it returns the sublist beginning with the first occurrence of the symbol 

#+BEGIN_SRC scheme
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))

(memq 'apple '(pear banana prune))
(memq 'apple '(x (apple sauce) y apple pear))
#+END_SRC

#+RESULTS:

*** Exercise 2.54 

#+BEGIN_SRC scheme
(define (equal? list1 list2)
  (cond ((null? list1) #t)
        ((eq? (car list1)
              (car list2))
         (equal? (cdr list1)
                 (cdr list2)))
        (else #f)))

(equal? '(this is a list)
        '(this (is a) list))
#+END_SRC

#+RESULTS:
: #f

*** Exercise 2.55 

#+BEGIN_SRC scheme
(car ''abracadabra)
#+END_SRC

#+RESULTS:
: quote

Eva is passing car a list of symbolic objects, ' and 'abracadabra. We see this by asking for the cdr and getting back abracadabra

#+BEGIN_SRC scheme
(cdr ''abracadabra)
#+END_SRC

#+RESULTS:
| abracadabra |

** Example: Symbolic Differentiation 

Consider the design of a procedure that performs symbolic differentiation of algebraic expressions. 

*** The differentiation program with abstract data 


#+BEGIN_SRC scheme
(define (variable? e))

(define (same-variable? v1 v2))

(define (sum? e))

(define (addend e))

(define (augend e))

(define (make-sum a1 a2))

(define (product? e))

(define (multiplier e))

(define (multiplicand e))

(define (make-product m1 m2))
#+END_SRC

#+RESULTS:

Using these primitives, we can write the rules for differentiation as follows:

#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product
           (multiplier exp)
           (deriv (multiplicand exp) var))
          (make-product
           (deriv (multiplier exp) var)
           (multiplicand exp))))
        (else (error "Unknown expression type: DERIV" exp))))
#+END_SRC

#+RESULTS:
: deriv


This procedure incorporates the complete differentiation algorithm. Since it is expressed in terms of abstract data, it will work no matter how we choose to represent algebraic expressions, as long as we design a proper set of selectors and constructors. 

*** Representing algebraic expressions 

Our data representation is the following: 

- The variables are symbols 

#+BEGIN_SRC scheme
(define (variable? x) (symbol? x))
#+END_SRC

#+RESULTS:
: variable?

- Two variables are the same if the symbols representing them are eq?

#+BEGIN_SRC scheme
(define (same-variable? v1 v2)
  (and (variable? v1)
       (variable? v2)
       (eq? v1 v2)))
#+END_SRC 

#+RESULTS:
: same-variable?

- Sums and products are constructed as lists 

#+BEGIN_SRC scheme
(define (make-sum a1 a2)
  (list '+ a1 a2))

(define (make-product m1 m2)
  (list '* m1 m2))
#+END_SRC

#+RESULTS:
: make-product

- A sum is a list whose first element is the symbol +

#+BEGIN_SRC scheme
(define (sum? x)
  (and (pair? x)
       (eq? (car x) '+)))
#+END_SRC

#+RESULTS:
: sum?

- The addend is the second item of the sum of the list 

#+BEGIN_SRC scheme
(define (addend s)
  (cadr s))
#+END_SRC

#+RESULTS:
: addend

- The augment is the third item of the sum of the list 

#+BEGIN_SRC scheme
(define (augend s)
  (caddr s))
#+END_SRC

#+RESULTS:
: augend

- and similarly for multiplication 

#+BEGIN_SRC scheme
(define (product? x)
  (and (pair? x)
       (eq? (car x) '*)))

(define (multiplier p)
  (cadr p))

(define (multiplicand p)
  (caddr p))
#+END_SRC

#+RESULTS:
: multiplicand

We should now have a fully working deriv function 

#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y)
           (+ x 3))
       'x)
#+END_SRC

#+RESULTS:
| + | (* (* x y) (+ 1 0)) | (* (+ (* x 0) (* 1 y)) (+ x 3)) |

This is correct, but the program doesn't manage to simplify the result of the expression. We can accomplish the needed reduction without modifying the higher level function, but instead changing the constructors and selectors. 

#+BEGIN_SRC scheme
(define (=number? exp num)
  (and (number? exp)
       (= exp num)))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1)
              (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0)
             (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1)
              (number? m2))
         (* m1 m2))
        (else (list '* m1 m2))))
#+END_SRC

#+RESULTS:
: make-product

#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y)
           (+ x 3))
       'x)
#+END_SRC

#+RESULTS:
| + | (* x y) | (* y (+ x 3)) |

The problem of algebraic simplification is complex because a form that may be simplest for one purpose may not be for another 

*** Exercise 2.56 

#+BEGIN_SRC scheme
(define (exponentiation? x)
  (and (pair? x)
       (eq? (car x)
          '**)))

(define (base x)
  (cadr x))

(define (exponent x)
  (caddr x))

(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        (else (list '** base exponent))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product
           (multiplier exp)
           (deriv (multiplicand exp) var))
          (make-product
           (deriv (multiplier exp) var)
           (multiplicand exp))))
        ((exponentiation? exp)
          (make-product
           (exponent exp)
           (make-product
            (make-exponentiation
             (base exp)
             (- (exponent exp) 1))
            (deriv (base exp) var))))
        (else (error "Unknown expression type: DERIV" exp))))

(deriv '(** x 5) 'x)
#+END_SRC

#+RESULTS:
| 5 | (** x 4) |

*** Exercise 2.57 

Extend the differentiation program to handle sums and products of arbitrary numbers of two or more terms by only changing the representation of sums and products. 

#+BEGIN_SRC scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (augend s)
  (accumulate make-sum 0 (cddr s)))

(define (multiplicand p)
  (accumulate make-product 1 (cddr p)))
#+END_SRC

#+RESULTS:
: multiplicand


#+BEGIN_SRC scheme
(deriv '(* x y (+ x 3)) 'x)
#+END_SRC

*** Exercise 2.58 

Solution stolen from schemewiki -- This is vpraid's modified shunting yard algorithm (by Dijkstra): 

https://en.wikipedia.org/wiki/Shunting-yard_algorithm


Pseudocode: 

1.  While there are tokens to be read:
2.        Read a token
3.        If it's a number add it to queue
4.        If it's an operator
5.               While there's an operator on the top of the stack with greater precedence:
6.                       Pop operators from the stack onto the output queue
7.               Push the current operator onto the stack
8.        If it's a left bracket push it onto the stack
9.        If it's a right bracket 
10.            While there's not a left bracket at the top of the stack:
11.                     Pop operators from the stack onto the output queue.
12.             Pop the left bracket from the stack and discard it
13. While there are operators on the stack, pop them to the queue

- So for step 2 and 3 we need a number? and operator? function 

- For the rest of the steps we need a stack implementation (can be done with lists) and to create left and right stacks for the numbers and operators 

- This procedure gives us reverse polish notation, when we really want prefix notation. In order to account for this, we need to make sure that operators are popped before numbers 


#+BEGIN_SRC scheme
(define (make-difference a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1)
              (number? a2))
         (- a1 a2))
        (else (list '- a1 a2))))

(define (op? o)
  (or (eq? o '+)
      (eq? o '-)
      (eq? o '*)
      (eq? o '**)))
  
(define (precedence o) 
  (cond ((eq? o '+) 1) 
        ((eq? o '-) 1) 
        ((eq? o '*) 2) 
        ((eq? o '**) 3) 
        (else (error "unknown operator: PRECEDENCE" o)))) 
  
(define (associativity o) 
  (cond ((eq? o '+) 'left) 
        ((eq? o '-) 'left) 
        ((eq? o '*) 'left) 
        ((eq? o '**) 'right) 
        (else (error "unknown operator: ASSOCIATIVITY" o)))) 
  
(define (shunting-yard exp) 
  (define (apply-op output op) 
    (let ((lhs (cadr output)) 
          (rhs (car output))) 
      (cons
       (cond ((eq? op '+) (make-sum lhs rhs)) 
             ((eq? op '-) (make-difference lhs rhs)) 
             ((eq? op '*) (make-product lhs rhs)) 
             ((eq? op '**) (make-exponentiation lhs rhs)) 
             (else error "unknown operator: APPLY-OP" op)) 
       (cddr output)))) 

  (define (iter output operators exp)
    (if (null? exp) 
        (if (null? operators) ; pushing whatever is left in op stack into output 
            (car output) 
            (iter (apply-op output (car operators))
                  (cdr operators) exp)) 
        (let ((token (car exp)))
          (cond ((list? token)     ; pushing sublist into output 
                 (iter (cons (shunting-yard token) output) operators (cdr exp))) 
                ((op? token) ; pushing new operation into output or op stack 
                 (if (and (not (null? operators))
                          (or (and (eq? (associativity token) 'left)
                                   (<= (precedence token)
                                       (precedence (car operators))))
                              (and (eq? (associativity token) 'right)
                                   (< (precedence token) 
                                      (precedence (car operators)))))) 
                     (iter (apply-op output (car operators))
                           (cdr operators)
                           exp)
                     (iter output
                           (cons token operators)
                           (cdr exp)))) 
                (else ; pushing new number or variable into output 
                 (iter (cons token output)
                       operators
                       (cdr exp))))))) 
  (iter '() '() exp))
#+END_SRC


#+BEGIN_SRC scheme
(shunting-yard '(x * y (x + 3)))
#+END_SRC

#+BEGIN_SRC scheme
(define (deriv-infix exp var)
  (deriv (shunting-yard exp) var))
#+END_SRC

#+RESULTS:
: deriv-infix

#+BEGIN_SRC scheme
(deriv '(* x y (+ x 3)) 'x)
#+END_SRC

#+RESULTS:
| + | (* x y) | (* y (+ x 3)) |

#+BEGIN_SRC scheme
(deriv-infix '(x * y (x + 3)) 'x)
(deriv-infix '(x + 3 * (x + y + 2)) 'y)
#+END_SRC

#+RESULTS:
: 3

** Example: Representing Sets 

Thus far we have built representations for two kinds of compound data objects: rational numbers and algebraic expressions. In one we had the choice of simplifying the expressions at either construction time or selection time. 

When we turn to the representation of sets, the choice of representation is not so obvious. 

Informally, a set is simply a collection of distinct objects. To give a more precise definition, we can employ the method of data abstraction and define sets by specifying the operations that are to be used on sets. 

These are: 

- union-set
- intersection-set
- element-of-set?
- adjoin-set

From the viewpoint of data abstraction, we are free to design any representation that implements these operations in a way consistent with the interpretations given above. 

*** Sets as unordered lists 

#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (intersection-set set1 set2)
  (cond ((or (null? set1)
             (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
#+END_SRC

- element-of-set is O(n)
- adjoin-set is O(n)
- intersection-set has to check for each element of each set, so it could be O(n^2)

*** Exercise 2.59 

Implement the union-set operation for the unordered-list representation of sets 

#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (cond ((and (null? set1)
              (null? set2)) '())
        ((null? set1) set2)
        ((null? set2) set1)
        ((not (element-of-set? (car set1) set2))
         (cons (car set1)
               (union-set (cdr set1) set2)))
        (else (union-set (cdr set1) set2))))

(union-set '(1 2 3 4) '(2 3 4 5))
(union-set '(1 2 3) '(1 2 3))
#+END_SRC

*** Exercise 2.60 

Suppose we allow duplicates. Design procedures that operate on this representation. 

#+BEGIN_SRC scheme
(define (element-of-set-dups? x set)
  (element-of-set? x set))

(define (adjoin-set-dups x set)
  (cons x set))

(define (drop-first x set)
  (if (equal? x (car set))
      (cdr set)
      (cons (car set)
            (drop-first x (cdr set)))))

(define (intersection-set-dups set1 set2)
  (cond ((or (null? set1)
             (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons
          (car set1)
          (intersection-set-dups (cdr set1)
                                 (drop-first
                                  (car set1) set2))))
        (else (intersection-set-dups (cdr set1) set2))))

(intersection-set-dups '(1 2 3 3 3 4 4 4 4) '(2 2 3 3 4 4 5))

(define (union-set-dups set1 set2)
  (append set1 set2))

(union-set-dups '(1 2 2 3 3 4 4) '(1 2 2 2 3 3 3 4 4 4))
#+END_SRC

How does the efficiency of each compare with the corresponding procedure for the non-duplicate representation? 

- element of set is the same, O(n)
- adjoin-set is constant time O(1)
- union-set with cons is constant time, with append it traverses the first set so O(n)
- intersection-set is O(n^2)


Are there applications for which you would use this representation in preference to the non-duplicate one? 

For applications in which we would expect to be mostly performing unions and adjoins as opposed to intersections. Also since this repeated set is such a normal thing, its just an unconstrained data structure. We would only need the regular set functions when we want that exact uniqueness constraint. 

*** Sets as ordered lists 

One way to speed up our set operations is to change the representation so that the set elements are listed in increasing order. 

An advantage or ordering shows up in element-of-set?: In checking for the presence of an item, we no longer have to scan the entire set. 

#+BEGIN_SRC scheme
(define (element-of-set-ordered? x set)
  (cond ((null? set) #f)
        ((= x (car set)) #t)
        ((< x (car set)) #f)
        (else (element-of-set-ordered? x (cdr set)))))

(element-of-set-ordered? 4 '(1 2 3 4 5 6))
#+END_SRC

We obtain a more impressive speed-up with intersection-set. 

- Compare the elements x1 and x2 of the first two sets. If x1 == x2, then that gives an element of the intersection and we can return that element and the cdrs of the two sets.
- If x1 < x2, since x2 is the smallest element of set2 we can drop x1.

#+BEGIN_SRC scheme
(define (intersection-set-o set1 set2)
  (if (or (null? set1)
          (null? set2))
      '()
      (let ((x1 (car set1))
            (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (intersection-set-o (cdr set1)
                                         (cdr set2))))
              ((< x1 x2)
               (intersection-set-o (cdr set1) set2))
              ((< x2 x1)
               (intersection-set-o set1 (cdr set2)))))))

(intersection-set-o '(1 2 4 6 7 8 9) '(2 3 4 6 8 10))
#+END_SRC

Observe that at each step we reduce the intersection problem to computing intersections of smaller sets. Thus, the number of steps required is at most the sum of the sizes of set1 and set2, rather than the product of sizes as with the unordered representation. This is O(n + m) = O(n) growth rather than O(n^2).

*** Exercise 2.61

Give an implementation of adjoin-set using the ordered representation.

#+BEGIN_SRC scheme
(define (adjoined-set-o x set)
  (cond ((null? set) x)
        ((= x (car set)) set)
        ((> x (car set))
         (cons (car set)
               (adjoined-set-o x (cdr set))))
        (else (cons x (cdr set)))))

(adjoin-set-o 5 '(1 2 3 4 6 7 8))
#+END_SRC

*** Exercise 2.62 

Give an O(n) implementation of union-set for sets represented as ordered lists. 


