* Symbolic Data 
:PROPERTIES:
:header-args: :session scheme :results value
:END:

In this section we extend the representational capability of our language by introducing the ability to work with arbitrary symbols as data. 

** Quotation 

In order to manipulate symbols we need a new element in our language: the ability to quote a data object.

#+BEGIN_SRC scheme
(define a 1)
(define b 2)

(list a b)
(list 'a 'b)
(list 'a b)
#+END_SRC

Quotation also allows us to type in compound objects, using the conventional printed representation for lists 

#+BEGIN_SRC scheme
(car '(a b c))
(cdr '(a b c))
#+END_SRC

eq? takes two symbols as arguments and test whether they are the same. With this we can implement memq, which takes two args: a symbol and a list. If the symbol is not contained in the list, then memq returns false, otherwise it returns the sublist beginning with the first occurrence of the symbol 

#+BEGIN_SRC scheme
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))

(memq 'apple '(pear banana prune))
(memq 'apple '(x (apple sauce) y apple pear))
#+END_SRC

#+RESULTS:
| apple | pear |

*** Exercise 2.54 

#+BEGIN_SRC scheme
(define (equal? list1 list2)
  (cond ((null? list1) #t)
        ((eq? (car list1)
              (car list2))
         (equal? (cdr list1)
                 (cdr list2)))
        (else #f)))

(equal? '(this is a list)
        '(this (is a) list))
#+END_SRC

#+RESULTS:
: #f

*** Exercise 2.55 

#+BEGIN_SRC scheme
(car ''abracadabra)
#+END_SRC

Eva is passing car a list of symbolic objects, ' and 'abracadabra. We see this by asking for the cdr and getting back abracadabra

#+BEGIN_SRC scheme
(cdr ''abracadabra)
#+END_SRC

** Example: Symbolic Differentiation 

Consider the design of a procedure that performs symbolic differentiation of algebraic expressions. 

*** The differentiation program with abstract data 


#+BEGIN_SRC scheme
(define (variable? e))

(define (same-variable? v1 v2))

(define (sum? e))

(define (addend e))

(define (augend e))

(define (make-sum a1 a2))

(define (product? e))

(define (multiplier e))

(define (multiplicand e))

(define (make-product m1 m2))
#+END_SRC

Using these primitives, we can write the rules for differentiation as follows:

#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product
           (multiplier exp)
           (deriv (multiplicand exp) var))
          (make-product
           (deriv (multiplier exp) var)
           (multiplicand exp))))
        (else (error "Unknown expression type: DERIV" exp))))
#+END_SRC

#+RESULTS:
: deriv


This procedure incorporates the complete differentiation algorithm. Since it is expressed in terms of abstract data, it will work no matter how we choose to represent algebraic expressions, as long as we design a proper set of selectors and constructors. 

*** Representing algebraic expressions 

Our data representation is the following: 

- The variables are symbols 

#+BEGIN_SRC scheme
(define (variable? x) (symbol? x))
#+END_SRC

#+RESULTS:
: variable?

- Two variables are the same if the symbols representing them are eq?

#+BEGIN_SRC scheme
(define (same-variable? v1 v2)
  (and (variable? v1)
       (variable? v2)
       (eq? v1 v2)))
#+END_SRC 

#+RESULTS:
: same-variable?

- Sums and products are constructed as lists 

#+BEGIN_SRC scheme
(define (make-sum a1 a2)
  (list '+ a1 a2))

(define (make-product m1 m2)
  (list '* m1 m2))
#+END_SRC

#+RESULTS:
: make-product

- A sum is a list whose first element is the symbol +

#+BEGIN_SRC scheme
(define (sum? x)
  (and (pair? x)
       (eq? (car x) '+)))
#+END_SRC

#+RESULTS:
: sum?

- The addend is the second item of the sum of the list 

#+BEGIN_SRC scheme
(define (addend s)
  (cadr s))
#+END_SRC

#+RESULTS:
: addend

- The augment is the third item of the sum of the list 

#+BEGIN_SRC scheme
(define (augend s)
  (caddr s))
#+END_SRC

#+RESULTS:
: augend

- and similarly for multiplication 

#+BEGIN_SRC scheme
(define (product? x)
  (and (pair? x)
       (eq? (car x) '*)))

(define (multiplier p)
  (cadr p))

(define (multiplicand p)
  (caddr p))
#+END_SRC

#+RESULTS:
: multiplicand

We should now have a fully working deriv function 

#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y)
           (+ x 3))
       'x)
#+END_SRC

#+RESULTS:
| + | (* (* x y) (+ 1 0)) | (* (+ (* x 0) (* 1 y)) (+ x 3)) |

This is correct, but the program doesn't manage to simplify the result of the expression. We can accomplish the needed reduction without modifying the higher level function, but instead changing the constructors and selectors. 

#+BEGIN_SRC scheme
(define (=number? exp num)
  (and (number? exp)
       (= exp num)))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1)
              (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0)
             (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1)
              (number? m2))
         (* m1 m2))
        (else (list '* m1 m2))))
#+END_SRC

#+RESULTS:
: make-product

#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)

(deriv '(* x y) 'x)

(deriv '(* (* x y)
           (+ x 3))
       'x)
#+END_SRC

The problem of algebraic simplification is complex because a form that may be simplest for one purpose may not be for another 

*** Exercise 2.56 

#+BEGIN_SRC scheme
(define (exponentiation? x)
  (and (pair? x)
       (eq? (car x)
          '**)))

(define (base x)
  (cadr x))

(define (exponent x)
  (caddr x))

(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        (else (list '** base exponent))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product
           (multiplier exp)
           (deriv (multiplicand exp) var))
          (make-product
           (deriv (multiplier exp) var)
           (multiplicand exp))))
        ((exponentiation? exp)
          (make-product
           (exponent exp)
           (make-product
            (make-exponentiation
             (base exp)
             (- (exponent exp) 1))
            (deriv (base exp) var))))
        (else (error "Unknown expression type: DERIV" exp))))

(deriv '(** x 5) 'x)
#+END_SRC

*** Exercise 2.57 

