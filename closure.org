* Hierarchical Data and the Closure Property 
:PROPERTIES:
:header-args: :session scheme :results value
:END:

The ability to create pairs whose elements are pairs is the essence of the list structures importance as a representational tools. We refer to this ability as the closure property of cons. 

In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation. 

Closure is the key to power in any means of combination because it permits us to create hierarchical structures -- structures made up of parts, which themselves are made up of parts, and so on. 

** Representing Sequences 

One of the useful structures we can build with pairs is a sequence - an ordered collection of data objects. 

#+BEGIN_SRC scheme
(cons 1 (cons 2 (cons 3 (cons 4 'nil))))
#+END_SRC

#+RESULTS:

Such a sequence of pairs, formed by nested conses, is called a list. We could have also made the structure above with the list function 

#+BEGIN_SRC scheme
(list 1 2 3 4)
#+END_SRC

#+BEGIN_SRC scheme
(define one_through_four (list 1 2 3 4))
#+END_SRC

#+RESULTS:
: one_through_four

#+BEGIN_SRC scheme
(car one_through_four)
(cdr one_through_four)
(cadr one_through_four)
(car (cdr (cdr one_through_four)))
#+END_SRC

*** List Operations 

- for n = 0, list-ref should return the car of the list
- otherwise, list-ref should return the (n - 1)st item of the cdr of the list 

#+BEGIN_SRC scheme
(define squares (list 1 4 9 16 25))

(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(list-ref squares 3)
#+END_SRC

#+RESULTS:
: 16

Often we cdr down the whole list. To aid in this, scheme includes the primitive procedure null?, which tests whether its argument is the empty list. 

#+BEGIN_SRC scheme
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))

(define odds (list 1 3 5 7))
(length odds)
#+END_SRC

#+RESULTS:
: 4

We could also compute length in an iterative style

#+BEGIN_SRC scheme
(define (length items)
  (define (iter items count)
    (if (null? items)
        count
        (iter (cdr items) (+ count 1))))
  (iter items 0))

(length odds)
#+END_SRC

#+RESULTS:
: 4

Another conventional programming technique is to cons up an answer list while cdring down a list, as in the procedure append, which takes two lists as arguments and combines their elements to make a new list. 

#+BEGIN_SRC scheme
(append squares odds)
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 | 25 | 1 | 3 | 5 | 7 |

#+BEGIN_SRC scheme
(append odds squares)
#+END_SRC

#+RESULTS:
| 1 | 3 | 5 | 7 | 1 | 4 | 9 | 16 | 25 |

#+BEGIN_SRC scheme
(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1)
            (append (cdr l1) l2))))

(append odds squares)
#+END_SRC

#+RESULTS:
| 1 | 3 | 5 | 7 | 1 | 4 | 9 | 16 | 25 |

*** Exercise 2.17 

Define a procedure last-pair that returns the list that contains only the last element of a given nonempty list 

(last-pair (list 23 72 149 34))
(34)

#+BEGIN_SRC scheme
(define (last-pair l1)
  (if (null? (cdr l1))
      (car l1)
      (last-pair (cdr l1))))

(last-pair (list 23 72 149 34))
#+END_SRC

#+RESULTS:
: 34

*** Exercise 2.18

Define a procedure reverse that takes a list as an argument and returns a list of the same elements in reverse order 

#+BEGIN_SRC scheme
(define (reverse l1)
  (if (null? (cdr l1))
      (car l1)
      (list (cons (reverse (cdr l1))
             (car l1)))))

(reverse (list 1 4 9 16 25))
#+END_SRC

#+RESULTS:
: ((((((((25 . 16)) . 9)) . 4)) . 1))

*** Exercise 2.20 

The procedures + * and list take arbitrary numbers of arguments. One way to define such a procedure is with dotted-tail-notation. In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedure is called, the initial parameters will have as values the initial arguments, but the last parameter will be a list of any remaining arguments. 

For instance, given the definition (define (f x y . z) <body>) the procedure f can be called with two or more arguments. 

Use this notation to write a procedure same-parity that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument. 

#+BEGIN_SRC scheme
(define (same-parity a . b)
  (cond ((null? (cdr b)) (car b))
        ((even? a)
         (if (even? (car b))
             (cons (car b)
                   (same-parity a (cdr b)))
             (same-parity a (cdr b))))
        (else
         (if (even? (car b))
             (same-parity a (cons b
                                  (cddr b)))
             (cons (car b)
                   (same-parity a (cdr b)))))))

(same-parity 1 2 3 4 5 6 7)
#+END_SRC

#+RESULTS:
| 3 | 4 | 5 | 6 | 7 |

#+BEGIN_SRC scheme
(define (same-parity a . b)
  (if (even? a)
      (cond
       ((null? (car b)) a)
       ((even? (car b))
             (cons (car b)
                   (same-parity a (cdr b))))
       (else (same-parity a (cdr b))))))

(same-parity 1 2 3 4 5)
#+END_SRC

#+RESULTS:
: 2

Not quite sure why this returns a list. This makes it not get past the first iteration. 

*** Mapping Over Lists 

#+BEGIN_SRC scheme
(define (scale-list items factor)
  (if (null? items)
      '()
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))

(scale-list (list 1 2 3 4 5) 10)
#+END_SRC

#+RESULTS:
| 10 | 20 | 30 | 40 | 50 |

#+BEGIN_SRC scheme
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))

(map abs (list -10 2.5 -11.6 17))
#+END_SRC

#+BEGIN_SRC scheme
(map (lambda (x) (* x x))
     (list 1 2 3 4))
#+END_SRC

Now we can give a new definition of scale-list in terms of map 

#+BEGIN_SRC scheme
(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))

(scale-list (list 1 2 3 4 5) 10)
#+END_SRC

Scheme standardly provides a map procedure that is more general than the one described here. It takes a procedure of n arguments, together with n lists, and applies the procedure to all the first elements of the lists, all the second elements of the lists, and so on, returning a list of the results. 

#+BEGIN_SRC scheme
(map + (list 1 2 3 4)
     (list 40 50 60)
     (list 700 800 900))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC scheme
(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
#+END_SRC

map is an important construct, not only because it captures a common pattern, but because it establishes a higher level of abstraction in dealing with lists. 


*** Exercise 2.21 

#+BEGIN_SRC scheme
(define (square-list items)
  (if (null? items)
      '()
      (cons (square (car items))
            (square-list (cdr items)))))

(square-list (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 | 25 |


#+BEGIN_SRC scheme
(define (square-list items)
  (map square items))

(square-list (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 | 25 |

*** Exercise 2.22 

#+BEGIN_SRC scheme
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items '()))

(square-list (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
| 25 | 16 | 9 | 4 | 1 |

#+BEGIN_SRC scheme
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items 0))

(square-list (list 1 2 3 4 5))
#+END_SRC

#+RESULTS:
