* A Register Machine Simulator 
:PROPERTIES:
:header-args: :session scheme :results verbatim raw
:ARCHIVE:
:END:

In this section we construct a simulator for machines described in the register machine language. The simulator is a scheme program with four interface procedures. 
The first uses a description of a register machine to construct a model of the machine (a data structure whose parts correspond to the parts of the machine to be simulated), and the other three allow us to simulate the machine by manipulating the model. 

#+BEGIN_SRC scheme
(make-machine register-names
              operations
              controller)

(set-register-contents! machine-model
                        register-name
                        value)

(get-register-contents machine-model
                       register-name)

(start machine-model)
#+END_SRC

As an example of how these are used, we can define gcd-machine as follows: 

#+BEGIN_SRC scheme
(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder)
         (list '= =))
   '(test-b
     (test (op =) (reg b) (const 0))
     (branch (label gcd-done))
     (assign t (op rem) (reg a) (reg b))
     (assign a (reg b))
     (assign b (reg t))
     (goto (label test-b))
     gcd-done)))
#+END_SRC

To compute gcds with this machine, we set the input registers, start the machine, and examine the result when the simulation terminates 

#+BEGIN_SRC scheme
(set-register-contents! gcd-machine 'a 206)
(set-register-contents! gcd-machine 'b 40)
(start gcd-machine)
(get-register-contents gcd-machine 'a)
#+END_SRC

*** Exercise 5.7

Use the simulator to test the machines you designed in exercise 5.4

#+BEGIN_SRC scheme
(set-register-contents! expt-machine 'a 5)
(set-register-contents! expt-machine 'n 2)
(start expt-machine)
(get-register-contents expt-machine 'a) ; 25 ?
#+END_SRC

** The Machine Model 

The machine model generated by make-machine is represented as a procedure with local state using the message-passing techniques developed in chapter 3. make-new-machine is essentially a container for some registers and a stack, together with an execution mechanism that processes the controller instructions one by one. 

make-machine then extends this basic model (by sending it messages) to include the registers, operations, and controller of the particular machine being defined. First it allocates a register in the new machine for each of the supplied register names and installs the designated operations in the machine. Then it uses an assembler to transform the controller list into instructions for the new machine and installs these as the machine's instruction sequence. 

#+BEGIN_SRC scheme
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register)
                 register-name))
              register-names)
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence) (assemble controller-text machine))
    machine))
#+END_SRC

** Registers 

We will represent a register as a procedure with local state. The procedure make-register creates a register that holds a value that can be accessed or changed: 

#+BEGIN_SRC scheme
(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value)
               (set! contents value)))
            (else (error "Unknown Request: REGISTER" message))))
    dispatch))

; accessors
(define (get-contents register)
  (register 'get))

(define (set-contents! register value)
  ((register 'set) value))
#+END_SRC

** The Stack 

We can also represent a stack as a procedure with local state. The procedure make-stack creates a stack whose local state consists of a list of the items on the stack. A stack accepts requests to push an item onto the stack, to pop the top item off the stack and return it, and to initialize the stack to empty. 

#+BEGIN_SRC scheme
(define (make-stack)
  (let ((s '()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize)
             (initialize))
            (else (error "Unknown Request: STACK" message))))
    dispatch))

; accessors
(define (pop stack)
  (stack 'pop))

(define (push stack value)
  ((stack 'push) value))
#+END_SRC

** The Basic Machine 

The make-new-machine procedure constructs an object where 
- local state consists of a stack
- an initially empty instruction sequence
- a list of operations that initially contain an operation to initialize the stack
- a register table that initially contains two registers named flag and pc (program counter)
- allocate-register adds new entries to the register table
- lookup-register looks up registers in the table 

The flag register is used to control branching in the simulated machine. test instructions set the contents of flag to the result (true or false). Branch instructions decide whether or not to branch by examining the contents of flag. 

The pc register determines the sequencing of instructions as the machine runs. This sequencing is implemented by the internal procedure execute. As part of its operation, each instruction execution procedure modifies pc to indicate the next instruction to be executed. branch and goto instructions change pc to point in the new destination. All other instructions simply advance pc, making it point to the next instruction in the sequence. 

#+BEGIN_SRC scheme
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops (list
                    (list 'initialize-stack (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc)
                 (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Muliply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register: " name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              (else (error "Unknown request: MACHINE" message))))
      dispatch)))

; for convenience we have an alternative procedural interface to a machine's staart operation, as well as procs to set and examine register contents 
(define (start machine)
  (machine 'start))

(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))

(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  'done)

(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
#+END_SRC

** The Assembler 

The assembler transforms the sequence of controller expressions for a machine into a corresponding list of machine instructions, each with its execution procedure. Overall, the assembler is much like the evaluators we studied in chapter 4 -- there is an input language (the register machine language) and we must perform an appropriate action for each type of expression in the language. 

Before it can generate the instruction execution procedures, the assembler must know what all the labels refer to, so it begins by scanning the controller text to separate the labels from the instructions. As it scans the text, it constructs both a lsit of instructions and a table that associates each label with a pointer into that list. Then the assembler augments the instruction list by inserting the execution procedure for each instruction. 

#+BEGIN_SRC scheme
(define (assemble controller-text machine)
  (extract-labels controller-text (lambda (insts labels)
                                    (update-insts! insts labels machine) insts)))

; sequentially scan the elements of the text accumulating insts and labels
; if ele is a label, add to labels table. ow accumulate onto the insts list
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr-text)
                      (lambda (insts labels)
                        (let ((next-inst (car text)))
                          (if (symbol? next-inst)
                              (receive insts (cons
                                              (make-label-entry next-inst insts)
                                              labels))
                              (receive (cons (make-instruction next-inst) insts)
                                  labels)))))))

; modify the instruction list to include the corresponding execution procedures
(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each (lambda (inst)
                (set-instruction-execution-proc! inst
                                                 (make-execution-procedure (instruction-text inst)
                                                                           labels
                                                                           machine
                                                                           pc
                                                                           flag
                                                                           stack
                                                                           ops)))
              insts)))

; pairs the instruction text with the corresponding execution procedure
(define (make-instruction text)
  (cons text '()))

(define (instruction-text inst)
  (car inst))

(define (instruction-execution-proc inst)
  (cdr inst))

(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))

; elements of the label table are pairs 
(define (make-label-entry label-name insts)
  (cons label-name insts))

; lookup entries in the table
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Undefined label: ASSEMBLE" label-name))))
#+END_SRC

*** Exercise 5.8 


** Generating Execution Procedures for Instructions 

The assembler calls make-execution-procedure to generate the execution procedure for an instruction. For each type of instruction in the register machine language, there is a generator that builds an appropriate execution procedure. 

#+BEGIN_SRC scheme
(define (make-execution-procedure inst labels machine pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Unknown instruction type: ASSEMBLE" inst))))
#+END_SRC

#+BEGIN_SRC scheme
; extract target register name and val exp and assign result to that register
(define (make-assign inst machine labels operations pc)
  (let ((target (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc (if (operation-exp? value-exp)
                          (make-operation-exp value-exp machine labels operations)
                          (make-primitive-exp (car value-exp) machine labels))))
      (lambda () (set-contents! target (value-proc))
         (advance-pc pc)))))

; selectors
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))

(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))

; termination for procedures
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
#+END_SRC

#+BEGIN_SRC scheme
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc (make-operation-exp condition
                                                  machine
                                                  labels
                                                  operations)))
          (lambda () (set-contents! flag (condition-proc))
             (advance-pc pc)))
        (error "Bad TEST instruction: ASSEMBLE" inst))))

(define (test-condition test-instruction)
  (cdr test-instruction))
#+END_SRC

#+BEGIN_SRC scheme
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction: ASSEMBLE" inst))))

(define (branch-dest branch-instruction)
  (cadr branch-instruction))
#+END_SRC

#+BEGIN_SRC scheme
; similar to branch, but the dest may be specified as either a label or register, and there is no condition to check 
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts (lookup-label labels (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg (get-register machine (register-exp-reg dest))))
             (lambda () (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction: ASSEMBLE" inst)))))

(define (goto-dest goto-instruction)
  (cadr goto-instruction))
#+END_SRC

#+BEGIN_SRC scheme
; stack instructions
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine (stack-inst-reg-name inst))))
    (lambda () (push stack (get-contents reg))
       (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine (stack-inst-reg-name inst))))
    (lambda () (set-contents! reg (pop stack))
       (advance-pc pc))))
#+END_SRC

#+BEGIN_SRC scheme
; generate execution procedure for the action to be performed 
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Bad PERFORM instruction: ASSEMBLE" inst))))

(define (perform-action inst)
  (cdr inst))
#+END_SRC

*** Execution Procedures for Subexpressions 

The value of a reg, label, or const expression may be needed for assignment to a register (make-assign) or for input to an operation (make-operation-exp). The following procedures generate execution procedures to produce values for these expressions during the simulation

#+BEGIN_SRC scheme
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else (error "Unknown expression type: ASSEMBLE" exp))))

(define (register-exp? exp)
  (tagged-list? exp 'reg))

(define (register-exp-reg exp)
  (cadr exp))

(define (constant-exp? exp)
  (tagged-list? exp 'const))

(define (constant-exp-value exp)
  (cadr exp))

(define (label-exp? exp)
  (tagged-list? exp 'label))

(define (label-exp-label exp)
  (cadr exp))
#+END_SRC

assign, perform, and test instructions may include the application of a machine operation (specified by an op expression) to some operands (specified by reg and const expressions). The following procedure produces an execution procedure for an "operation expression" - a list containing the operation and operand expressions from the instruction. 

#+BEGIN_SRC scheme
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs (map (lambda (e) (make-primitive-exp e machine labels))
                     (operation-exp-operands exp))))
    (lambda () (apply op (map (lambda (p) (p)) aprocs)))))

(define (operation-exp? exp)
  (and (pair? exp)
       (tagged-list? (car exp) 'op)))

(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))

(define (operation-exp-operands operation-exp)
  (cdr operation-exp))

(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation: ASSEMBLE" symbol))))
#+END_SRC

*** Exercise 5.9 

The treatment of machine operations above permits them to operate on labels as well as on constants and the contents of registers. 

Modify the expression processing procedures to enforce the condition that operations can be used only with registers and constants. 

#+BEGIN_SRC scheme
; reference 
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ; get rid of / pass with some kind of break
        ;; ((label-exp? exp)
        ;;  (let ((insts
        ;;         (lookup-label labels (label-exp-label exp))))
        ;;    (lambda () insts)))
        ; get rid of / pass with some kind of break
        ((label-exp? exp)
         (error "Only registers and constants allowed: ASSEMBLE" exp))
        ((register-exp? exp)
         (let ((r (get-register machine (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else (error "Unknown expression type: ASSEMBLE" exp))))

(define (register-exp? exp)
  (tagged-list? exp 'reg))

(define (register-exp-reg exp)
  (cadr exp))

(define (constant-exp? exp)
  (tagged-list? exp 'const))

(define (constant-exp-value exp)
  (cadr exp))

; remove
(define (label-exp? exp)
  (tagged-list? exp 'label))

(define (label-exp-label exp)
  (cadr exp))
; remove

; alternatively
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs (map (lambda (e) (if (label-exp? e)
                                (error "Only registers and constants allowed: ASSEMBLE" e)
                                (make-primitive-exp e machine labels)))
                     (operation-exp-operands exp))))
    (lambda () (apply op (map (lambda (p) (p)) aprocs)))))

(define (operation-exp? exp)
  (and (pair? exp)
       (tagged-list? (car exp) 'op)))

(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))

(define (operation-exp-operands operation-exp)
  (cdr operation-exp))

(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation: ASSEMBLE" symbol))))
#+END_SRC

*** Exercise 5.10 

Design a new syntax for register-machine instructions and modify the simulator to use your new syntax. 

This is awesome, but pass due to time constraints 

** Monitoring Machine Performance 

Simulation is useful not only for verifying the correctness of a proposed machine design, but also for measuring the machine's performance. 

For example, we can install in our simulation program a meter that measures the number of stack operations used in a computation. We also add an operation to the basic machine model to print the stack statistics.

#+BEGIN_SRC scheme
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics) (print-statistics))
            (else (error "Unknown request: STACK" message))))
    dispatch))
#+END_SRC

exercises 15 through 19 describe other useful monitoring and debugging features that can be added to the register machine simulator. 

*** Exercise 5.15 

Add instruction counting to the register machine simulation. Extend the machine model's interface to accept a new message that prints the value of the instruction count and resets the count to 0.

#+BEGIN_SRC scheme
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0)
        (inst-count 0))
    (define (inst-count-val)
      (newline)
      (display "The instruction count is currently: " inst-count)
      (newline)
      (display "Resetting count")
      (set! inst-count 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth))
      (set! inst-count (+ inst-count 1)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            (set! inst-count (+ inst-count 1))
            top)))
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      (set! inst-count 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes '= number-pushes
                     'maximum-depth '= max-depth
                     'num-inst '= inst-count)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics) (print-statistics))
            ((eq? message 'reset-inst) (inst-count-val))
            (else (error "Unknown request: STACK" message))))
    dispatch))

(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '())
        (inst-count 0))
    (let ((the-ops (list
                    (list 'initialize-stack (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc)
                 (list 'flag flag))))
      (define (print-inst-num)
        (newline)
        (display "The current instruction count is" inst-count)
        (newline)
        (display "Resetting count")
        (set! inst-count 0))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Muliply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register: " name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution proc (car insts)))
                (execute)
                (set! inst-count (+ inst-count 1))))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'get-inst-count) print-inst-num)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              (else (error "Unknown request: MACHINE" message))))
      dispatch)))

#+END_SRC

*** Exercise 5.16

Augment the simulator to provide for instruction tracing. Before each instruction is executed, the simulator should print the text of the instruction. 

#+BEGIN_SRC scheme
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '())
        (inst-count 0)
        (trace 'on))
    (let ((the-ops (list
                    (list 'initialize-stack (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc)
                 (list 'flag flag))))
      (define (print-inst-num)
        (newline)
        (display "The current instruction count is" inst-count)
        (newline)
        (display "Resetting count")
        (set! inst-count 0))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Muliply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register: " name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                (if (eq? trace 'on)
                    (begin (display (caar insts))
                           (newline)))
                ((instruction-execution proc (car insts)))
                (execute)
                (set! inst-count (+ inst-count 1))))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'trace-on) (set! trace 'on))
              ((eq? message 'trace-off) (set! trace 'off))
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'get-inst-count) print-inst-num)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              (else (error "Unknown request: MACHINE" message))))
      dispatch)))
#+END_SRC

