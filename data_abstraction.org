* Data Abstraction
:PROPERTIES:
:header-args: :session scheme :results output
:END:

Data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects.

We wish to structure our programs such that they use compound data objects that operate on "abstract data". Programs should use data in such a way as to make -no- assumptions about the data that is not strictly necessary for performing the task at hand. 

** Arithmetic Operations for Rational Numbers

Lets assume that we already have a way of constructing a rational number from a numerator and denominator. We also assume that we have a way of extracting the numerator and denominator from a rational number. 

- (make-rat <n><d>) returns a rational number 
- (numer <x>) returns numerator
- (denom <x>) returns denominator 


#+DOWNLOADED: /tmp/screenshot.png @ 2020-02-16 09:16:29
[[file:Data Abstraction/screenshot_2020-02-16_09-16-29.png]]

#+BEGIN_SRC scheme
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))


(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
#+END_SRC

#+RESULTS:

*** Pairs

#+BEGIN_SRC scheme
(define x (cons 1 2))

(car x)
(cdr x)
#+END_SRC

#+BEGIN_SRC scheme
(define y (cons 3 4))
(define z (cons x y))

(car (car z))
(car (cdr z))
#+END_SRC

#+RESULTS:
: 3

Data objects constructed from pairs are called list-structured data. 

*** Representing Rational Numbers

Pairs offer a natural way to complete the rational number system. Represent a rational number as a pair of two integers.

#+BEGIN_SRC scheme
(define (make-rat x y)
  (cons x y))
(define (numer x) (car x))
(define (denom x) (cdr x))

(define (print-rat x)
  (newline)
  (display (numer x))
  (display '"/")
  (display (denom x)))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC scheme
(define one-half (make-rat 1 2))
(print-rat one-half)
#+END_SRC

#+RESULTS:
: 
: 1/2


#+BEGIN_SRC scheme
(define one-third (make-rat 1 3))
(print-rat one-third)
#+END_SRC

#+RESULTS:
: 
: 1/3

#+BEGIN_SRC scheme
(print-rat (add-rat one-half one-third))
#+END_SRC

#+RESULTS:
: 
: 5/6

#+BEGIN_SRC scheme
(print-rat (mul-rat one-half one-third))
#+END_SRC

#+RESULTS:
: 
: 1/6

#+BEGIN_SRC scheme
(print-rat (add-rat one-third one-third))
#+END_SRC

#+RESULTS:
: 
: 6/9

As this last example shows, our implementation doesn't simplify. We can remedy this by changing make-rat. 

#+BEGIN_SRC scheme
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC scheme
(print-rat (add-rat one-third one-third))
#+END_SRC

#+RESULTS:
: 
: 2/3
