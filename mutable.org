* Modeling with Mutable Data
:PROPERTIES:
:header-args: :session scheme :results verbatim raw
:END:

The desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects, as well as to construct and select from them. We will design data abstractions to include mutators, which modify data objects. Data objects for which mutators are defined are known as mutable data objects. 

** Mutable List Structure 

The basic operations on pairs - cons, car, and cdr are incapable of modifying list structure. To modify list structures we need new operations. 

The primitive mutators for pairs are set-car! and set-cdr!. The first takes two arguments, the first of which must be a pair. It replaces the car pointer by a pointer to the second argument to set-car! 

The set-cdr! operation is similar, except that it sets the pointer for the cdr instead. 

cons builds new list structure by creating new pairs, while set-c*r! modify existing pairs. We could implement cons in terms of the two mutators, together with a procedure get-new-pair which returns a new pair that is not part of any existing list structure. 

#+BEGIN_SRC scheme
(define (cons-mut x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
#+END_SRC

#+RESULTS:

*** Exercise 3.12 

The following was introduced in 2.2.1: 

#+BEGIN_SRC scheme
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
#+END_SRC

#+RESULTS:
: append

The procedure append! is similar, but it is a mutator rather than a constructor. It appends the lists by splicing them together, modifying the final pair of x so that its cdr is now y. 

#+BEGIN_SRC scheme
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
#+END_SRC

Consider the interaction 

#+BEGIN_SRC scheme
(define x (list 'a 'b))

(define y (list 'c 'd))

(define z (append x y))

z
(cdr x)
(define w (append! x y))
w
(cdr x)
#+END_SRC

#+RESULTS:
| b | c | d |

*** Exercise 3.13 

Consider the following make-cycle procedure which uses the last-pair procedure defined above. 

#+BEGIN_SRC scheme
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
#+END_SRC

Draw a box and pointer diagram that shows the structure z created by 

#+BEGIN_SRC scheme
(define z (make-cycle (list 'a 'b 'c)))
z
#+END_SRC

we essentially have a circular linked list. 

What happens if we try to compute (last-pair z)?

#+BEGIN_SRC scheme
(last-pair z)
#+END_SRC

We enter an infinite loop, since the last pair is also the first pair. 

*** Exercise 3.14 

The following procedure is quite useful, although quite obscure

#+BEGIN_SRC scheme
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
#+END_SRC

Explain what mystery does in general. 

It reverses the list

'(1 2 3 4) -> '(4 3 2 1)

*** Sharing and Identity 

#+BEGIN_SRC scheme
(define x (list 'a 'b))
(define z1 (cons x x))
#+END_SRC

returns: 

#+DOWNLOADED: /tmp/screenshot.png @ 2020-03-31 21:29:03
[[file:Modeling with Mutable Data/screenshot_2020-03-31_21-29-03.png]]

In contrast

#+BEGIN_SRC scheme
(define z2 (cons (list 'a 'b)
                 (list 'a 'b)))
#+END_SRC


returns 


#+DOWNLOADED: /tmp/screenshot.png @ 2020-03-31 21:29:44
[[file:Modeling with Mutable Data/screenshot_2020-03-31_21-29-44.png]]

In general, sharing is completely undetectable if we operate on lists using only cons, car and cdr. However, if we allow mutators on list structure, sharing becomes significant. 

Consider the following procedure, which modifies the car of the structure to which it is applied: 

#+BEGIN_SRC scheme
(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
#+END_SRC

Even though z1 and z2 are the "same" structure, applying set-to-wow to them yields different results. With z1, changing the car also changes the cdr, because in z1 the car and cdr are the same pair. 

With z2 the car and cdr are distinct, so set-to-wow! only modifies the car: 

#+BEGIN_SRC scheme
z1
#+END_SRC

#+RESULTS:
| (a b) | a | b |

#+BEGIN_SRC scheme
(set-to-wow! z1)
#+END_SRC

#+RESULTS:
| (wow b) | wow | b |

#+BEGIN_SRC scheme
z2
#+END_SRC

#+RESULTS:
| (a b) | a | b |

#+BEGIN_SRC scheme
(set-to-wow! z2)
#+END_SRC

#+RESULTS:
| (wow b) | a | b |

As we will see in the following sections, we can exploit sharing to greatly extend the repertoire of data structures that can be represented by pairs. This can also be dangerous, since modifications made to structures will also affect other structures that happen to share the modified parts. These mutation operations should be used with care, for unless we have a good understanding of how our data objects are shared, mutation can have unexpected results. 

*** Exercise 3.15

From scheme-wiki:

; z1 -> ( . )
;        | |
;        v v
; x --> ( . ) -> ( . ) -> null
;        |        |
;        v        v
;       'wow     'b

; z2 -> ( . ) -> ( . ) -> ( . ) -> null
;        |        |        |
;        |        v        v
;        |       'a       'b
;        |                 ^
;        |                 |
;        `-----> ( . ) -> ( . ) -> null
;                 |
;                 v
;                'wow

*** Exercise 3.16 

Ben Bitdiddle decides to write a procedure to count the number of pairs in any list structure. 

#+BEGIN_SRC scheme
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
#+END_SRC

#+RESULTS:
count-pairs

Show that this procedure is not correct. 

#+BEGIN_SRC scheme
'((1 1) (1 1) (1 1))
#+END_SRC

Draw box and pointer diagrams representing list structures of exactly 3 pairs for which Ben's procedure would return 

3

#+BEGIN_SRC scheme
(define zipf (list 'a 'b 'c))
(count-pairs zipf)
#+END_SRC

#+RESULTS:
3

4

#+BEGIN_SRC scheme
(count-pairs (list zipf)) 
#+END_SRC 

7
#+BEGIN_SRC scheme
(count-pairs (cons zipf zipf)) 
#+END_SRC

Infinite loop

#+BEGIN_SRC scheme
(set-cdr! (cddr zipf) zipf)
(count-pairs zipf)
#+END_SRC

returns ;Aborting!: maximum recursion depth exceeded

*** Exercise 3.17 

Devise a correct version of the count-pairs procedure of 3.16 that returns the number of distinct pairs in any data structure.

Hint: Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted

#+BEGIN_SRC scheme
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))

(define slist '(a b c))

(define (seen? x seen-list)
  (cond ((null? seen-list) #f)
        ((eq? x (car seen-list)) #t)
        (else (seen? x (cdr seen-list)))))

(define (count-pairs x)
  (let ((slist '()))
    (cond ((not (pair? (car x))) 0)
          ((not (seen? (car x)))
           (begin (append! slist (car x))
                  (+ (count-pairs (car x))
                     (count-pairs (cdr x))
                     1)))
          ;; (else (count-pairs (cdr x)))
          )))

(count-pairs (list '(a b) '(b c) '(c d)))
(count-pairs (list 'a 'b 'c))
(count-pairs (list (list 1 2) (list 3 4) (list 5 6)))
(pair? (car (list '(a b) '(b c) '(c d))))

(define (count-pairs x)
  (let ((encountered '()))
    (define (helper x)
      (if (or (not (pair? x))
              (memq x encountered))
          0
          (begin (set! encountered (cons x encountered))
                 (+ (helper (car x))
                    (helper (cdr x))
                    1))))
    (helper x)))
(count-pairs (list (zipf zipf)))

#+END_SRC

Couldn't get it to work. The solution doesn't seem to solve the problem 

*** Exercise 3.18 

Write a procedure that examines a list and determines whether it contains a cycle


The idea is to see if the cdr of a list is equal to the list itself. We can do this by keeping a copy of each of the elements of the list, checking along the way if the cdr is equal to the entire list. This will be true when we do the n+1st iteration and check our cdr against our aggregated data structure. 

https://stackoverflow.com/questions/694669/what-is-the-scheme-function-to-find-an-element-in-a-list

What is the difference between the three different functions? It's based on which equivalence function they use for comparison. *eq? (and thus memq) tests if two objects are the same underlying object*; it is basically equivalent to a pointer comparison (or direct value comparison in the case of integers). Thus, two strings or lists that look the same may not be eq?, because they are stored in different locations in memory. equal? (and thus member?) performs a deep comparison on lists and strings, and so basically any two items that print the same will be equal?. eqv? is like eq? for almost anything but numbers; for numbers, two numbers that are numerically equivalent will always be eqv?, but they may not be eq? (this is because of bignums and rational numbers, which may be stored in ways such that they won't be eq?)

#+BEGIN_SRC scheme
(cycle? (list 1 2 3 1))
(define zoop (list 1 3 4))
(set-cdr! (cddr zoop) zoop)
(cycle? zoop)

(define (cycle? ls)
  (let ((seen '()))
    (define (recurse ls)
      (if (not (pair? ls))
          #f
          (if (memq ls seen)
              #t
              (begin (set! seen (cons ls seen))
                     (or (recurse (car ls))
                         (recurse (cdr ls)))))))
    (recurse ls)))  
#+END_SRC

*** Exercise 3.19 
Redo 3.18 using an algorithm that takes only a constant amount of space 

Floyd's cycle-finding algorithm is a pointer algorithm that uses only two pointers, which move through the sequence at different speeds. It is also called the "tortoise and the hare algorithm", alluding to Aesop's fable of The Tortoise and the Hare.

#+BEGIN_SRC scheme
(define (cycle? ls)
  (define (floyd turtle hare)
    (cond ((or (null? turtle)
               (or (null? hare)
                   (null? (cdr hare)))) #f)
     ((eq? turtle hare) #t)
     (else (floyd (cdr turtle)
                  (cddr hare)))))
  (floyd ls (cdr ls)))
#+END_SRC

*** Mutation is just assignment 

When we introduced compound data, we observed that pairs can be represented purely in terms of procedures: 

#+BEGIN_SRC scheme
(define (cons-prod x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined Operation CONS-PROD" m))))
  dispatch)

(define (car-prod z)
  (z 'car))

(define (cdr-prod z)
  (z 'cdr))

(cdr-prod (cons-prod 2 (list 1 2 3)))
#+END_SRC

The same holds true for mutable data. We can implement mutable data objects using assignment and local state.

#+BEGIN_SRC scheme
(define (cons-mut x y)
  (define (set-x! v)
    (set! x v))
  (define (set-y! v)
    (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error "Undefined Operation CONS-MUT" m))))
  dispatch)

(define (car-mut z)
  (z 'car))
(define (cdr-mut z)
  (z 'cdr))
(define (set-car-mut! z new-val)
  ((z 'set-car!) new-val))
(define (set-cdr-mut! z new-val)
  ((z 'set-cdr!) new-val))

(define zipf (cons-mut 'a 'b))
(cdr-mut zipf)
#+END_SRC

** Representing Queues 

The mutators set-car and set-cdr enable us to use pairs to construct data structures that cannot be built with cons, car, and cdr alone. This section shows how to use pairs to represent a queue. 

A queue is sometimes called a FIFO buffer. In terms of data abstractions we can regard a queue as being defined by the following set of operations: 

- a constructor 
  - (make-queue) returning an empty queue
- two selectors 
  - (empty-queue? queue) test if the queue is empty 
  - (front-queue queue) returns the object at the front of the queue 
- two mutators
  - (insert-queue! queue item) inserts an item at the rear of the queue and returns the modified queue
  - (delete-queue! queue) removes the item at the front of the queue and returns the modified queue as its value 

A queue is represented as a pair of pointers, front-ptr and rear-ptr, which indicate the first and last pairs of an ordinary list. We can use cons to combine the two pointers, giving us our representation: 

#+BEGIN_SRC scheme
(define (front-ptr queue) 
  (car queue))

(define (rear-ptr queue)
  (cdr queue))

(define (set-front-ptr! queue item)
  (set-car! queue item))

(define (set-rear-ptr! queue item)
  (set-cdr! queue item))
#+END_SRC


Now we can focus on the queue operations: 

#+BEGIN_SRC scheme
(define (make-queue)
  (cons '() '()))

(define (empty-queue? queue)
  (null? (front-ptr queue)))

(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with empty queue")
      (car (front-ptr queue))))

(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))

(define (delete-queue! queue)
  (if (empty-queue? queue)
      (error "Cannot delete first element from empty queue")
      (begin (set-front-ptr! queue (cdr (front-ptr queue)))
             queue)))
#+END_SRC

*** Exercise 3.21 

Ben Bitdiddle decides to test the queue implementation described above. 

#+BEGIN_SRC scheme
(define q1 (make-queue))
(insert-queue! q1 'a)
(insert-queue! q1 'b)
(insert-queue! q1 'c)
(insert-queue! q1 'd)
(insert-queue! q1 'e)
(insert-queue! q1 'f)
(insert-queue! q1 'g)
(delete-queue! q1)
(delete-queue! q1)
#+END_SRC

The queue representation is a pair. When we delete all the elements of a queue, we are changing the pointer at the front of the queue. We never actually touch the rear-ptr of the queue here, so when we print the queue we are seeing the unchanging rear-ptr.

#+BEGIN_SRC scheme
 (define (print-queue queue)
  (display (front-ptr queue)))

(define (print-queue queue)
  (map display (front-ptr queue)))

(print-queue q1)
#+END_SRC

*** Exercise 3.22 

Instead of representing a queue as a pair of pointers, we can build a queue as a procedure with local state. The local state will consist of pointers to the beginning and the end of an ordinary list. Thus, the make-queue procedure will have the form:

#+BEGIN_SRC scheme
(define (make-queue)
  (let ((front-ptr ...)
        (rear-ptr ...))
    <definitions of internal procedures>
    (define (dispatch m)
      ...)
    dispatch))
#+END_SRC

Complete the definition and provide implementations of the queue operations using this representation. 

#+BEGIN_SRC scheme
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (set-front-ptr! item)
      (set! front-ptr item))
    (define (set-rear-ptr! item)
      (set! rear-ptr item))
    (define (empty-queue?)
      (eq? front-ptr '()))
    (define (front-queue)
      (if (empty-queue?)
          (error "Front called with an empty queue")
          (car front-ptr)))
    (define (insert item)
      (let ((new-pair (cons item '())))
        (cond ((empty-queue?)
               (set-front-ptr! new-pair)
               (set-rear-ptr! new-pair))
              (else
               (set-cdr! rear-ptr new-pair)
               (set-rear-ptr! new-pair)))))
    (define (delete-queue!)
      (cond ((empty-queue?)
             (error "Delete called with an empty queue"))
            (else (set-front-ptr! (cdr front-ptr)))))
    (define (print-queue)
      (map display front-ptr))
    (define (dispatch m)
      (cond ((eq? m 'empty-queue?) empty-queue?)
            ((eq? m 'front-queue) front-queue)
            ((eq? m 'insert) insert)
            ((eq? m 'delete-queue!) delete-queue!)
            ((eq? m 'print-queue) print-queue)
            (else (error "Operation not found!" m))))
    dispatch))

(define zoop (make-queue))

((zoop 'insert) 'g)
((zoop 'print-queue))
((zoop 'delete-queue!))
#+END_SRC

*** Exercise 3.23 

A deque (double ended queue) is a sequence in which items can be inserted and deleted at either the front or the rear. Operations on deques are 

- Constructor 
  - make-deque
- Predicate 
  - empty-deque?
- Selectors 
  - front-deque 
  - rear-deque 
- Mutators 
  - front-insert-deque! 
  - rear-insert-deque! 
  - front-delete-deque! 
  - rear-delete-deque! 

Show how to represent deques using pairs, and give implementations of the operations. 

#+BEGIN_SRC scheme
(define (make-deque)
  (cons '() '()))

(define (front-ptr deque)
  (car deque))

(define (rear-ptr deque)
  (cdr deque))

(define (empty-deque? deque)
  (null? (front-ptr deque)))

(define (set-front-deque! deque item)
  (set-car! deque item))

(define (set-rear-deque! deque item)
  (set-cdr! deque item))

(define (front-deque deque)
  (if (empty-deque? deque)
      '()
      (car (front-ptr deque))))

(define (rear-deque deque)
  (if (empty-deque? deque)
      '()
      (car (rear-ptr deque))))

(define (front-insert-deque! deque item)
  (let ((new-pair (cons item '())))
    (cond ((empty-deque? deque)
           (set-front-deque! deque new-pair)
           (set-rear-deque! deque new-pair)
           deque)
          (else
           (set-cdr! new-pair (front-ptr deque))
           (set-front-deque! deque new-pair)
           deque))))

(define (rear-insert-deque! deque item)
  (let ((new-pair (cons item '())))
    (cond ((empty-deque? deque)
           (set-front-deque! deque new-pair)
           (set-rear-deque! deque new-pair))
          (else
           (set-cdr! (rear-ptr deque) new-pair)
           (set-rear-deque! deque new-pair)
           deque))))

(define (print-deque deque)
  (map display (front-ptr deque)))

(define zipf (make-deque))

;; are you watching closely?

(front-insert-deque! zipf 'c)
(rear-insert-deque! zipf 'a)
(front-insert-deque! zipf 'a)
(rear-insert-deque! zipf 'd)
(front-insert-deque! zipf 'r)
(rear-insert-deque! zipf 'a)
(front-insert-deque! zipf 'b)
(rear-insert-deque! zipf 'b)
(front-insert-deque! zipf 'a)
(rear-insert-deque! zipf 'r)
(rear-insert-deque! zipf 'a)

(print-deque zipf)
#+END_SRC

** Representing Tables 

Here we see how to build tables as mutable list structures. 

We first consider a 1d table in which each value is stored under a single key. We implement the table as a list of records, each of which is implemented as a pair consisting of a key and the corresponding value. The records are glued together to form a list by pairs whose cars point to successive records. These gluing pairs are called the backbone of the table. 

lookup is defined in terms of the assoc operation, which expects a key and a list of records as arguments. assoc returns the record that has the given key as its car.

#+BEGIN_SRC scheme
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        #f)))

(define (assoc key records)
  (cond ((null? records) #f)
        ((equal? key (caar records))
         (car records))
        (else (assoc key (cdr records)))))

#+END_SRC

#+RESULTS:
assoc


To insert a value in a table under a given key, we first use assoc to see if there is already a record in the table with this key. If not, we form a new record by consing the key with the value and insert this at the head of the table's list of records, after the top dummy record. If there is a record with this key, we set the cdr of this record to the designated new value. 

#+BEGIN_SRC scheme
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value)
                        (cdr table)))))
  'ok)
#+END_SRC

To construct a table, we simply create a list containing the symbol *table* 

#+BEGIN_SRC scheme
(define (make-table)
  (list '*table*)) 
#+END_SRC

#+BEGIN_SRC scheme
(define flubber (make-table))

(insert! 'a 10 flubber)
(insert! 'b 20 flubber)
(insert! 'c 30 flubber)
(insert! 'd 40 flubber)
(insert! 'e 50 flubber)

(lookup 'b flubber)
#+END_SRC

*** Two-Dimensional Tables 

In a two-dimensional table, each value is indexed by two keys. We can construct such a table as a one-dimensional table in which each key identifies a subtable. 

When we look up an item, we use the first key to identify the correct subtable. Then we use the second key to identify the record within the subtable. 

#+BEGIN_SRC scheme
(define (lookup key1 key2 table)
  (let ((subtable (assoc key1 (cdr table))))
    (if subtable
        (let ((record (assoc key2 (cdr subtable))))
          (if record
              (cdr record)
              #f))
        #f)))
#+END_SRC

To insert a new item under a pair of keys, we use assoc to see if there is a subtable stored under the first key. If not, we build a new subtable containing the single record (key2, value) and insert it into the table under the first key. If a subtable already exists for the first key, we insert the new record into this subtable using the insertion method for one-dimensional tables described above

#+BEGIN_SRC scheme
(define (insert! key1 key2 value table)
  (let ((subtable (assoc key1 (cdr table))))
    (if subtable
        (let ((record (assoc key2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key1
                              (cons key2 value))
                        (cdr table)))))
  'ok)
#+END_SRC

*** Creating Local Tables 

Our lookup and insert! operations above take the table as an argument -- this enables us to use programs that access more than one table. 

We could deal with multiple tables by having a separate lookup and insert! procedure for each table. We do this by representing a table procedurally, as an object that maintains an internal table as part of its local state. When sent an appropriate message, this table object supplies the procedure with which to operate on the internal table. 

#+BEGIN_SRC scheme
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key1 key2)
      (let ((subtable (assoc key1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key1 key2 value)
      (let ((subtable (assoc key1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key1 (cons key2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown Operation: TABLE" m))))
    dispatch))
#+END_SRC

Using make-table we could implement the get and put operations used in 2.4.3 for data-directed programming as follows:

#+BEGIN_SRC scheme
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
#+END_SRC

get takes as argments two keys, and put takes as arguments two keys and a value. Both operations access the same local table, which is encapsulated within the object created by the call to make-table. 

*** Exercise 3.24 

In the table implementations above, the keys are tested for equality using equal? (called by assoc). This is not always the appropriate test.
For example, we might have a table with numeric keys in which we don't need an exact match to the number we're looking up, but only a number within some tolerance of it. Design a table constructor make-table that takes as an argument a same-key? procedure that will be used to test "equality" of keys.


#+BEGIN_SRC scheme

(define (make-table same-key?)
  (let ((local-table (list '*table*)))
    (define (assoc key records)
      (cond ((null? records) #f)
            ((same-key? key (caar records))
             (car records))
            (else (assoc key (cdr records)))))
    (define (lookup key1 key2)
      (let ((subtable (assoc key1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key1 key2 value)
      (let ((subtable (assoc key1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key1 (cons key2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown Operation: TABLE" m))))
    dispatch))

#+END_SRC

*** Exercise 3.25 

Generalizing one and two dimensional tables, show how to implement a table in which values are stored under an arbitrary number of keys and different values may be stored under different numbers of keys. 

Thought process: 

We have the table implementation above that allows for a two 2d table. We essentially define which "column" the key is in, then we select that column and look for the key. In order to generalize it, we need to generalize all the methods of the table object that are limited to 2 keys.

In this case, those would be lookup and insert! 

Here is the original for reference:

#+BEGIN_SRC scheme

(define (make-table)
  (let ((local-table (list '*table*)))
    (define (assoc key records)
      (cond ((null? records) #f)
            ((equal? key (caar records))
             (car records))
            (else (assoc key (cdr records)))))
    (define (lookup key1 key2)
      (let ((subtable (assoc key1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key1 key2 value)
      (let ((subtable (assoc key1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key1 (cons key2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown Operation: TABLE" m))))
    dispatch))

#+END_SRC

and the update: 

#+BEGIN_SRC scheme
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (assoc key records)
      (cond ((null? records) #f)
            ((equal? key (caar records))
             (car records))
            (else (assoc key (cdr records)))))

    (define (lookup key-list)
      (if (null? key-list)
          false
          (let ((subtable (assoc (car key-list) (cdr local-table))))
            (if subtable
                (let ((record (assoc (cdr key-list) (cdr subtable))))
                  (if record
                      (cdr record)
                      false))
                (lookup (cdr key-list))))))
    
    (define (insert! key-list value)
      (define (get-there keys)
        (let ((result (assoc (car keys) (cdr local-table))))
          (if (null? (cdr keys))
              (if result
                  (set-cdr! (result value))
                  (set-cdr! local-table
                            (cons (cons (cons (car keys) value) '()) (cdr local-table))))
              (if result
                  (get-there (cdr keys))
                  (begin (set-cdr! local-table
                                   (cons (cons (cons (cdr keys) value) '()) (cadr local-table))))))))
      (get-there key-list))
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown Operation: TABLE" m))))
    dispatch))
#+END_SRC

*** Exercise 3.26 

Describe a table implementation where the (key, value) records are organized using a binary tree, assuming the keys can be ordered in some way.

First we set up the representation for the tree. Before we had (node left right), but in this case our node is a key value pair.

#+BEGIN_SRC scheme
(define (make-tree node left right)
  (list node left right))

(define (tree-node tree)
  (car tree))

(define (tree-left tree)
  (cadr tree))

(define (tree-right tree)
  (caddr tree))

(define (tree-node-key tree-node)
  (car tree-node))

(define (tree-node-value tree-node)
  (cdr tree-node))
#+END_SRC

Then we can reimplement the table's structure

#+BEGIN_SRC scheme
(define (make-tree-table)
  (let ((local-table '()))
    
    (define (adjoin-set x set) 
      (cond ((null? set) (make-tree x '() '())) 
            ((= (car x) (car (tree-node set))) set) 
            ((< (car x) (car (tree-node set))) 
             (make-tree (tree-node set) 
                        (adjoin-set x (tree-left set)) 
                        (tree-right set))) 
            ((> (car x) (car (tree-node set))) 
             (make-tree (tree-node set) 
                        (tree-left set) 
                        (adjoin-set x (tree-right set)))))) 
    
    (define (lookup key table)
      (cond ((null? table) #f)
            ((= key (tree-node-key table))
             (tree-node-value table))
            ((< key (tree-node-key table))
             (lookup key (tree-left table)))
            ((> key (tree-node-key table))
             (lookup key (tree-right table)))))
    
    (define (insert! key value)
      (let ((record (lookup key local-table)))
        (if record
            (set-cdr! record value)
            (set! local-table (adjoin-set (cons key value) local-table)))))

    (define (lookup-key key)
      (lookup key local-table))
    
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert) insert!)
            ((eq? m 'print) local-table)
            (else (error "Undefined Operation -- TABLE" m))))
    dispatch))

(define zipf (make-tree-table))
(define get (zipf 'lookup))
(define put (zipf 'insert))

(put 43 'a)
#+END_SRC

Neither 25 nor 26 work 

*** Exercise 27 

#+BEGIN_SRC scheme
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result
             (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))

(define memo-fib
  (memoize
   (lambda (n)
     (cond ((= n 0) 0)
           ((= n 1) 1)
           (else (+ (memo-fib (- n 1))
                    (memo-fib (- n 2))))))))

(memo-fib 6)
#+END_SRC

memo-fib computed the nth fibonacci number in steps proportional to n because the lookup table allows us to cache each step previously computed and then use those to get the next step. 

** A Simulator for Digital Circuits 

In this section we design a system for performing digital logic simulations. This typifies a type of program called an event-driven simulation, in which actions ("events") trigger further events that happen at a later time, which in turn trigger more events, and so on. 

Our computational model of a circuit will be composed of objects that correspond to the elmentary components from which the circuit is constructed. 

There are wires, which carry digital signals that may be 0 or 1. There are also various types of digital function boxes, which connect wires carrying input signals to other output wires. 

#+BEGIN_SRC scheme
(define (half-adder a b s c)
  (let ((d (make-wire))
        (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
#+END_SRC

#+RESULTS:
half-adder
half-adder

Now we can use half-adder itself as a building block in creating more complex circuits. 

#+BEGIN_SRC scheme
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
#+END_SRC

*** Primitive Function Boxes 

The primitive function boxes implement the forces by which a change in the signal on one wire influences the signals on other wires. To build these, we use the following operations on wires:

- (get-signal wire) returns the current value of the signal on the wire
- (set-signal! wire new-val) changes the value of the signal on the wire to the new value
- (add-action! wire procedure of no args) asserts that the designated procedure should be run whenever the signal on the wire changes value. These are the vehicles by which changes in the signal value on the wire are communicated to other wires 

Now we can definite primitive digital logic functions. To connect an input to an output through an inverter, we use add-action! to associate with the input wire a procedure that will be run whenever the signal on the input wire changes value. The procedure computes the logical-not of the input signal, and then, after one inverter-delay, sets the output signal to be this new value: 

#+BEGIN_SRC scheme
(define (inverter input output)
  (define (invert-input)
    (let ((new-val (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda () (set-signal! output new-val)))))
  (add-action! input invert-input))

(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid Signal" s))))

(define (and-gate a1 a2 output)
  (define (and-action-proc)
    (let ((new-val (logical-and (get-signal a1)
                                (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda () (set-signal! output new-val)))))
  (add-action! a1 and-action-proc)
  (add-action! a2 and-action-proc)
  'ok)

(define (logical-and s1 s2)
  (cond ((and (= s1 1)
              (= s2 1)) 1)
        ((or (= s1 0)
             (= s2 0)) 0)
        (else (error "Invalid Signals" s1 s2))))
#+END_SRC

*** Exercise 3.28 

Define an or-gate as a primitive function box. 

#+BEGIN_SRC scheme
(define (logical-or s1 s2)
  (cond ((or (= s1 1)
              (= s2 1)) 1)
        ((= s1 0) 0)
        (else (error "Invalid Signals" s1 s2))))

(define (or-gate a1 a2 output)
  (define (or-action-proc)
    (let ((new-val (logical-or (get-signal a1)
                               (get-signal a2))))
      (after-delay or-date-delay
                   (lambda () (set-signal! output new-val)))))
  (add-action a1 or-action-proc)
  (add-action a2 or-action-proc)
  'ok)
#+END_SRC

*** Exercise 3.29 

Another way to construct an or-gate is as a compound digital logic device, built from and-gates and inverters. Define a procedure or-gate that accomplishes this. What is the delay time of the or-gate in terms or gate-delay and inverter-delay? 

AND
1 1 1
1 0 0 
0 1 0
0 0 0

OR
1 1 1
1 0 1
0 1 1
0 0 0

NAND
1 1 0
1 0 1 
0 1 1
0 0 1

A B -A -B n-a-b
1 1  0  0   1
1 0  0  1   1
0 1  1  0   1
0 0  1  1   0

So our or gate can be expressed as nand(not(a), not(b))

and our gate diagram looks like 

a -- > |
       NAND(., .) --
b -- > |

#+BEGIN_SRC scheme
(define (logical-nand a b)
  (if (and (= a 1)
            (= n 1))
       #f
       #t))

(define (nand-gate a1 a2 output)
  (define (nand-action-proc)
    (let ((new-val (logical-nand (get-signal a1)
                                 (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda () (set-signal! output new-val)))))
  (add-action! a1 nand-action-proc)
  (add-action! a2 nand-action-proc)
  'ok)

(define (or-gate-and a b)
  (let ((c make-wire)
        (d make-wire)
        (e make-wire))
    (inverter a c)
    (inverter b d)
    (nand-gate c d e)))
#+END_SRC

*** Exercise 3.30 

Write a procedure ripple-carry-adder that generates the circuit 

As a reminder, here is the full-adder

#+BEGIN_SRC scheme
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
#+END_SRC

We need to feed in the c value to the first adder

Then for each full adder, we need to pass the sum, a, and b, and input the previous adders c and push out the new-c. 

If we reach the end of the list, our output is 0.

All we are missing to have a proper traversal of all these lists in parallel is:
- the list of c values starting with C input itself 
- the list of c values out, which will be the lagged outputs of each of the adders concluding with c_n = 0



#+BEGIN_SRC scheme
(define (ripple-carry-adder a-list b-list s-list c)
  (let ((c-list-vals (map (lambda (x) (make-wire)) (cdr a-list)))
        (c-list-in (append (list c) c-list-out))
        (c-list-out (append c-list-vals (make-wire))))
    (map full-adder a-list b-list c s-list c-list-out)))
#+END_SRC

** Representing Wires 

A wire in our simulation will be a computational object with two local state variables: a signal-value (initially 0) and a collection to action-procedures to be run when the signal changes value. 

The local-procedure set-my-signal! tests whether the new signal value changes the signal on the wire. If so, it runs each of the action procedures, using the following procedure call-each, which calls each of the items in a list of no-argument procedures. 

#+BEGIN_SRC scheme
(define (make-wire)
  (let ((signal-value 0)
        (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures
            (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown Operation: WIRE" m))))
    dispatch))

(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin ((car procedures))
             (call-each (cdr procedures)))))

(define (get-signal wire)
  (wire 'get-signal))

(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))

(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
#+END_SRC

We have modeled wires as procedures with local state variables that are modified by assignment. When a new wire is created, a new set of state variables is allocated and a new dispatch procedure is constructed and returned, capturing the environment with the new state variables. 

The wires are shared among the devices connected to them, so a change made by an interaction with one device will affect all of the other devices attached to the wire. 

** The Agenda 

We need to maintain a data structure, called an agenda, that contains a schedule of things to do. 

- (make-agenda) returns an empty agenda
- (empty-agenda? agenda) true is agenda is empty
- (first-agenda-item agenda) car agenda
- (remove-first-agenda-item! agenda) modifies the agenda by removing the first item
- (add-to-agenda! time action agenda) modifies the agenda by adding the given action procedure to be run at the specified time
- (current-time agenda) returns the current simulation time 

The procedure after-delay adds new elements to the-agenda

#+BEGIN_SRC scheme
(define (after-delay delay action)
   (add-to-agenda!
   (+ delay (current-time the-agenda))
   action
   the-agenda))
#+END_SRC

The simulation is driven by the procedure propagate, operating on the-agenda, executing each procedure on the agenda in sequence.

#+BEGIN_SRC scheme
(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item
             (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
#+END_SRC

*** A Sample Simulation 

The probe tells the wire that, whenever its signal changes value, it should print the new signal value, together with the current time and a name that identifies the wire:

#+BEGIN_SRC scheme
(define (probe name wire)
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display " New-value = ")
                 (display (get-signal wire)))))
#+END_SRC

Initialize the agenda and specify delays for the primitive function boxes 

#+BEGIN_SRC scheme
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
#+END_SRC

Define 4 wires, placing probes on 2 of them

#+BEGIN_SRC scheme
(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))

(probe 'sum sum)
(probe 'carry carry)
(half-adder input-1 input-2 sum carry)
(set-signal! input-1 1)
(propagate)
#+END_SRC

*** Exercise 3.31 

The internal procedure accept-action-procedure! defined in make-wire specifies that when a new action procedrue is added to a wire, the procedure is immediately run. Explain why this initialization is necessary. 

** Implementing the Agenda 

The agenda data structure holds the procedures that are scheduled for future execution. 

The agenda is made up of time segments, which consist of a number (the time) and a queue that holds the procedures that are scheduled to be run during that time segment. 

#+BEGIN_SRC scheme
(define (make-time-segment time queue)
  (cons time queue))

(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))
#+END_SRC

The agenda itself is a 1 dimensional table of time segments. 

#+BEGIN_SRC scheme
(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda)
  (car (segments agenda)))
(define (rest-segments agenda)
  (cdr (segments agenda)))
(define (empty-agenda? agenda)
  (null? (segments agenda)))
#+END_SRC

If we reach the end of the agenda, we must create a new time segment at the end:

#+BEGIN_SRC scheme
(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments)) action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
#+END_SRC

The procedure that removes the first item from the agenda deletes the item at the front of the queue in the first time segment. If this deletion makes the time segment empty, we remove it from the list of segments

#+BEGIN_SRC scheme
(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
#+END_SRC

The first agenda item is found at the head of the queue in the first time segment. Whenever we extract an item, we also update the current time

#+BEGIN_SRC scheme
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty: FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
#+END_SRC

*** Exercise 3.32 

** Propagation of Constraints 

In this section, we sketch the design of a language that enables us to work in terms of relations themselves.

The primitive elements of the language are primitive constraints, which state that certain relations hold between quantities. 

Our language provides a means of combining primitive constraints in order to express more complex relations. We combine constraints by constructing constraint networks, in which constraints are joined by connectors. A connector is an object that holds a value that may participate in one or more constraints. 

Computation by such a network proceeds as follows:

When a connector is given a value (by the user or by a constraint box to which it is linked), it awakens all of its associated constraints (except for the constraint that just awakened it) to inform them that it has a value. 

Each awakened constraint box then polls its connectors to see if there is enough information to determine a value for a connector. If so, the box sets that connector, which then awakens all of its associated constraints, and so on. 

*** Using the Constraint System 

#+BEGIN_SRC scheme
(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
#+END_SRC

#+BEGIN_SRC scheme
(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
#+END_SRC

Placing a probe on a connector will cause a message to be printed whenever the connector is given a value:

#+BEGIN_SRC scheme
(probe "Celsius Temp" C)
(probe "Fahrenheit Temp" F)

(set-value! C 25 'user)
(set-value! F 212 'user)

(forget-value! C 'user)
(set-value! F 212 'user)
#+END_SRC

#+RESULTS:

The nondirectionality of computation is the distinguishing feature of constraint based systems.

*** Implementing the Constraint System 

- (has-value? connector) tells whether the constructor has a value
- (get-value connector) returns the connector's current value
- (set-value! connector new-value informant) indicates that the informant is requesting the connector to set its value to the new value
- (forget-value! connector retractor) tells the connector that the retractor is requesting it to forget its value
- (connect connector new-constraint) tells the connector to participate in the new constraint 

The connectors communicate with the constraints by means of the procedures inform-about-value, which tells the given constraint that the connector has a value, and inform-about-no-value which tells the constraint that the connector has lost its value. 

adder constructs an adder constraint among summand connectors a1 and a2 and a sum connector. 

#+BEGIN_SRC scheme
(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1)
                (has-value? a2))
           (set-value! sum
                       (+ (get-value a1)
                          (get-value a2))
                       me))
          ((and (has-value? a1)
                (has-value? sum))
           (set-value! a2
                       (- (get-value sum)
                          (get-value a1))
                       me))
          ((and (has-value? a2)
                (has-value? sum))
           (set-value! a1
                       (- (get-value sum)
                          (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error "Unknown Request: ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
#+END_SRC

adder connects the new adder to the designated connectors and returns it as its value. The procedure me, which represents the adder, acts as a dispatch to the local procedures. 

#+BEGIN_SRC scheme
(define (inform-about-value constraint)
  (constraint 'I-have-a-value))

(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
#+END_SRC

#+BEGIN_SRC scheme
(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1)
                    (= (get-value m1) 0))
               (and (has-value? m2)
                    (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1)
                (has-value? m2))
           (set-value! product
                       (* (get-value m1)
                          (get-value m2))
                       me))
          ((and (has-value? m1)
                (has-value? product))
           (set-value! m2
                       (/ (get-value product)
                          (get-value m1))
                       me))
          ((and (has-value? m2)
                (has-value? product))
           (set-value! m1
                       (/ (get-value product)
                          (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error "Unknown Request: MULTIPLIER" request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
#+END_SRC

A constant constructor simple sets the value of the designated connector. Any I-have-a-value or I-lost-my-value message sent to the constant box will produce an error 

#+BEGIN_SRC scheme
(define (constant value connector)
  (define (me request)
    (error "Unknown Request: CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)
#+END_SRC

Finally, a probe prints a message about the setting or unsetting of the designated connector 

#+BEGIN_SRC scheme
(define (probe name connector)
  (define (print-probe value)
    (newline)
    (display "Probe: ")
    (display name)
    (display " = ")
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error "Unknown Request: PROBE" request))))
  (connect connector me)
  me)
#+END_SRC

*** Representing Connectors 

#+BEGIN_SRC scheme
(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception)
           (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))

(define (make-connector)
  (let ((value false)
        (informant false)
        (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Contradiction" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error "Unknown Operation: CONNECTOR" request))))
    me))


(define (has-value? connector)
  (connector 'has-value?))

(define (get-value connector)
  (connector 'value))

(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))

(define (forget-value! connector retractor)
  ((connector 'forget) retractor))

(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))


#+END_SRC

The local procedure set-my-value is called when there is a request to set the connector's value. If the connector doesn't have a value, it will set its value and remember as informant the constraint that requested the value to be set. 

*** Exercise 3.33

Using primitive multiplier, adder, and constant constraints, define a procedure averager that takes 3 connectors, a, b, and c as inputs and establishes the constraint that the value of c is the average of the values of a and b. 

#+BEGIN_SRC scheme

(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))

(define (averager a b c)
  (let ((u (make-connector))
        (v (make-connector)))
    (adder a b u)
    (constant 0.5 v)
    (multiplier c v u))
  'ok)
#+END_SRC
