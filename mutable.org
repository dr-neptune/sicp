* Modeling with Mutable Data
:PROPERTIES:
:header-args: :session scheme :results verbatim raw
:END:

The desire to model systems composed of objects that have changing state leads us to the need to modify compound data objects, as well as to construct and select from them. We will design data abstractions to include mutators, which modify data objects. Data objects for which mutators are defined are known as mutable data objects. 

** Mutable List Structure 

The basic operations on pairs - cons, car, and cdr are incapable of modifying list structure. To modify list structures we need new operations. 

The primitive mutators for pairs are set-car! and set-cdr!. The first takes two arguments, the first of which must be a pair. It replaces the car pointer by a pointer to the second argument to set-car! 

The set-cdr! operation is similar, except that it sets the pointer for the cdr instead. 

cons builds new list structure by creating new pairs, while set-c*r! modify existing pairs. We could implement cons in terms of the two mutators, together with a procedure get-new-pair which returns a new pair that is not part of any existing list structure. 

#+BEGIN_SRC scheme
(define (cons-mut x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
#+END_SRC

*** Exercise 3.12 

The following was introduced in 2.2.1: 

#+BEGIN_SRC scheme
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
#+END_SRC

The procedure append! is similar, but it is a mutator rather than a constructor. It appends the lists by splicing them together, modifying the final pair of x so that its cdr is now y. 

#+BEGIN_SRC scheme
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
#+END_SRC

Consider the interaction 

#+BEGIN_SRC scheme
(define x (list 'a 'b))

(define y (list 'c 'd))

(define z (append x y))

z
(cdr x)
(define w (append! x y))
w
(cdr x)
#+END_SRC

#+RESULTS:
| b | c | d |

*** Exercise 3.13 

Consider the following make-cycle procedure which uses the last-pair procedure defined above. 

#+BEGIN_SRC scheme
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
#+END_SRC

Draw a box and pointer diagram that shows the structure z created by 

#+BEGIN_SRC scheme
(define z (make-cycle (list 'a 'b 'c)))
z
#+END_SRC

we essentially have a circular linked list. 

What happens if we try to compute (last-pair z)?

#+BEGIN_SRC scheme
(last-pair z)
#+END_SRC

We enter an infinite loop, since the last pair is also the first pair. 

*** Exercise 3.14 

The following procedure is quite useful, although quite obscure

#+BEGIN_SRC scheme
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
#+END_SRC

Explain what mystery does in general. 

It reverses the list

'(1 2 3 4) -> '(4 3 2 1)

*** Sharing and Identity 

#+BEGIN_SRC scheme
(define x (list 'a 'b))
(define z1 (cons x x))
#+END_SRC

returns: 

#+DOWNLOADED: /tmp/screenshot.png @ 2020-03-31 21:29:03
[[file:Modeling with Mutable Data/screenshot_2020-03-31_21-29-03.png]]

In contrast

#+BEGIN_SRC scheme
(define z2 (cons (list 'a 'b)
                 (list 'a 'b)))
#+END_SRC


returns 


#+DOWNLOADED: /tmp/screenshot.png @ 2020-03-31 21:29:44
[[file:Modeling with Mutable Data/screenshot_2020-03-31_21-29-44.png]]

In general, sharing is completely undetectable if we operate on lists using only cons, car and cdr. However, if we allow mutators on list structure, sharing becomes significant. 

Consider the following procedure, which modifies the car of the structure to which it is applied: 

#+BEGIN_SRC scheme
(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
#+END_SRC

Even though z1 and z2 are the "same" structure, applying set-to-wow to them yields different results. With z1, changing the car also changes the cdr, because in z1 the car and cdr are the same pair. 

With z2 the car and cdr are distinct, so set-to-wow! only modifies the car: 

#+BEGIN_SRC scheme
z1
#+END_SRC

#+RESULTS:
| (a b) | a | b |

#+BEGIN_SRC scheme
(set-to-wow! z1)
#+END_SRC

#+RESULTS:
| (wow b) | wow | b |

#+BEGIN_SRC scheme
z2
#+END_SRC

#+RESULTS:
| (a b) | a | b |

#+BEGIN_SRC scheme
(set-to-wow! z2)
#+END_SRC

#+RESULTS:
| (wow b) | a | b |

As we will see in the following sections, we can exploit sharing to greatly extend the repertoire of data structures that can be represented by pairs. This can also be dangerous, since modifications made to structures will also affect other structures that happen to share the modified parts. These mutation operations should be used with care, for unless we have a good understanding of how our data objects are shared, mutation can have unexpected results. 

*** Exercise 3.15

From scheme-wiki:

; z1 -> ( . )
;        | |
;        v v
; x --> ( . ) -> ( . ) -> null
;        |        |
;        v        v
;       'wow     'b

; z2 -> ( . ) -> ( . ) -> ( . ) -> null
;        |        |        |
;        |        v        v
;        |       'a       'b
;        |                 ^
;        |                 |
;        `-----> ( . ) -> ( . ) -> null
;                 |
;                 v
;                'wow

*** Exercise 3.16 

Ben Bitdiddle decides to write a procedure to count the number of pairs in any list structure. 

#+BEGIN_SRC scheme
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
#+END_SRC

#+RESULTS:
count-pairs

Show that this procedure is not correct. 

#+BEGIN_SRC scheme
'((1 1) (1 1) (1 1))
#+END_SRC

Draw box and pointer diagrams representing list structures of exactly 3 pairs for which Ben's procedure would return 

3

#+BEGIN_SRC scheme
(define zipf (list 'a 'b 'c))
(count-pairs zipf)
#+END_SRC

#+RESULTS:
3

4

#+BEGIN_SRC scheme
(count-pairs (list zipf)) 
#+END_SRC 

7
#+BEGIN_SRC scheme
(count-pairs (cons zipf zipf)) 
#+END_SRC

Infinite loop

#+BEGIN_SRC scheme
(set-cdr! (cddr zipf) zipf)
(count-pairs zipf)
#+END_SRC

returns ;Aborting!: maximum recursion depth exceeded

*** Exercise 3.17 

Devise a correct version of the count-pairs procedure of 3.16 that returns the number of distinct pairs in any data structure.

Hint: Traverse the structure, maintaining an auxiliary data structure that is used to keep track of which pairs have already been counted

#+BEGIN_SRC scheme
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))

(define slist '(a b c))

(define (seen? x seen-list)
  (cond ((null? seen-list) #f)
        ((eq? x (car seen-list)) #t)
        (else (seen? x (cdr seen-list)))))

(define (count-pairs x)
  (let ((slist '()))
    (cond ((not (pair? (car x))) 0)
          ((not (seen? (car x)))
           (begin (append! slist (car x))
                  (+ (count-pairs (car x))
                     (count-pairs (cdr x))
                     1)))
          ;; (else (count-pairs (cdr x)))
          )))

(count-pairs (list '(a b) '(b c) '(c d)))
(count-pairs (list 'a 'b 'c))
(count-pairs (list (list 1 2) (list 3 4) (list 5 6)))
(pair? (car (list '(a b) '(b c) '(c d))))

(define (count-pairs x)
  (let ((encountered '()))
    (define (helper x)
      (if (or (not (pair? x))
              (memq x encountered))
          0
          (begin (set! encountered (cons x encountered))
                 (+ (helper (car x))
                    (helper (cdr x))
                    1))))
    (helper x)))
(count-pairs (list (zipf zipf)))

#+END_SRC

Couldn't get it to work. The solution doesn't seem to solve the problem 

*** Exercise 3.18 

Write a procedure that examines a list and determines whether it contains a cycle


The idea is to see if the cdr of a list is equal to the list itself. We can do this by keeping a copy of each of the elements of the list, checking along the way if the cdr is equal to the entire list. This will be true when we do the n+1st iteration and check our cdr against our aggregated data structure. 

https://stackoverflow.com/questions/694669/what-is-the-scheme-function-to-find-an-element-in-a-list

What is the difference between the three different functions? It's based on which equivalence function they use for comparison. *eq? (and thus memq) tests if two objects are the same underlying object*; it is basically equivalent to a pointer comparison (or direct value comparison in the case of integers). Thus, two strings or lists that look the same may not be eq?, because they are stored in different locations in memory. equal? (and thus member?) performs a deep comparison on lists and strings, and so basically any two items that print the same will be equal?. eqv? is like eq? for almost anything but numbers; for numbers, two numbers that are numerically equivalent will always be eqv?, but they may not be eq? (this is because of bignums and rational numbers, which may be stored in ways such that they won't be eq?)

#+BEGIN_SRC scheme
(cycle? (list 1 2 3 1))
(define zoop (list 1 3 4))
(set-cdr! (cddr zoop) zoop)
(cycle? zoop)

(define (cycle? ls)
  (let ((seen '()))
    (define (recurse ls)
      (if (not (pair? ls))
          #f
          (if (memq ls seen)
              #t
              (begin (set! seen (cons ls seen))
                     (or (recurse (car ls))
                         (recurse (cdr ls)))))))
    (recurse ls)))  
#+END_SRC

*** Exercise 3.19 
Redo 3.18 using an algorithm that takes only a constant amount of space 

Floyd's cycle-finding algorithm is a pointer algorithm that uses only two pointers, which move through the sequence at different speeds. It is also called the "tortoise and the hare algorithm", alluding to Aesop's fable of The Tortoise and the Hare.

#+BEGIN_SRC scheme
(define (cycle? ls)
  (define (floyd turtle hare)
    (cond ((or (null? turtle)
               (or (null? hare)
                   (null? (cdr hare)))) #f)
     ((eq? turtle hare) #t)
     (else (floyd (cdr turtle)
                  (cddr hare)))))
  (floyd ls (cdr ls)))
#+END_SRC

*** Mutation is just assignment 

When we introduced compound data, we observed that pairs can be represented purely in terms of procedures: 

#+BEGIN_SRC scheme
(define (cons-prod x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined Operation CONS-PROD" m))))
  dispatch)

(define (car-prod z)
  (z 'car))

(define (cdr-prod z)
  (z 'cdr))

(cdr-prod (cons-prod 2 (list 1 2 3)))
#+END_SRC

The same holds true for mutable data. We can implement mutable data objects using assignment and local state.

#+BEGIN_SRC scheme
(define (cons-mut x y)
  (define (set-x! v)
    (set! x v))
  (define (set-y! v)
    (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error "Undefined Operation CONS-MUT" m))))
  dispatch)

(define (car-mut z)
  (z 'car))
(define (cdr-mut z)
  (z 'cdr))
(define (set-car-mut! z new-val)
  ((z 'set-car!) new-val))
(define (set-cdr-mut! z new-val)
  ((z 'set-cdr!) new-val))

(define zipf (cons-mut 'a 'b))
(cdr-mut zipf)
#+END_SRC

** Representing Queues 

The mutators set-car and set-cdr enable us to use pairs to construct data structures that cannot be built with cons, car, and cdr alone. This section shows how to use pairs to represent a queue. 

A queue is sometimes called a FIFO buffer. In terms of data abstractions we can regard a queue as being defined by the following set of operations: 

- a constructor 
  - (make-queue) returning an empty queue
- two selectors 
  - (empty-queue? queue) test if the queue is empty 
  - (front-queue queue) returns the object at the front of the queue 
- two mutators
  - (insert-queue! queue item) inserts an item at the rear of the queue and returns the modified queue
  - (delete-queue! queue) removes the item at the front of the queue and returns the modified queue as its value 

A queue is represented as a pair of pointers, front-ptr and rear-ptr, which indicate the first and last pairs of an ordinary list. We can use cons to combine the two pointers, giving us our representation: 

#+BEGIN_SRC scheme
(define (front-ptr queue)
  (car queue))

(define (rear-ptr queue)
  (cdr queue))

(define (set-front-ptr! queue item)
  (set-car! queue item))

(define (set-rear-ptr! queue item)
  (set-cdr! queue item))
#+END_SRC

Now we can focus on the queue operations: 

#+BEGIN_SRC scheme
(define (make-queue)
  (cons '() '()))

(define (empty-queue? queue)
  (null? (front-ptr queue)))

(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with empty queue")
      (car (front-ptr queue))))

(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))

(define (delete-queue! queue)
  (if (empty-queue? queue)
      (error "Cannot delete first element from empty queue")
      (begin (set-front-ptr! queue (cdr (front-ptr queue)))
             queue)))
#+END_SRC

*** Exercise 3.21 

Ben Bitdiddle decides to test the queue implementation described above. 

#+BEGIN_SRC scheme
(define q1 (make-queue))
(insert-queue! q1 'a)
(insert-queue! q1 'b)
(insert-queue! q1 'c)
(insert-queue! q1 'd)
(insert-queue! q1 'e)
(insert-queue! q1 'f)
(insert-queue! q1 'g)
(delete-queue! q1)
(delete-queue! q1)
#+END_SRC

The queue representation is a pair. When we delete all the elements of a queue, we are changing the pointer at the front of the queue. We never actually touch the rear-ptr of the queue here, so when we print the queue we are seeing the unchanging rear-ptr.

#+BEGIN_SRC scheme
(define (print-queue queue)
  (display (front-ptr queue)))

(define (print-queue queue)
  (map display (front-ptr queue)))

(print-queue q1)
#+END_SRC

*** Exercise 3.22 

Instead of representing a queue as a pair of pointers, we can build a queue as a procedure with local state. The local state will consist of pointers to the beginning and the end of an ordinary list. Thus, the make-queue procedure will have the form:

#+BEGIN_SRC scheme
(define (make-queue)
  (let ((front-ptr ...)
        (rear-ptr ...))
    <definitions of internal procedures>
    (define (dispatch m)
      ...)
    dispatch))
#+END_SRC

Complete the definition and provide implementations of the queue operations using this representation. 

#+BEGIN_SRC scheme
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (set-front-ptr! item)
      (set! front-ptr item))
    (define (set-rear-ptr! item)
      (set! read-ptr item))
    (define make-queue (cons front-ptr rear-ptr))
    (define empty-queue?
      (eq? front-ptr '()))
    (define front-queue
      (if (empty-queue?)
          (error "Front called with an empty queue")
          (car front-ptr)))
    (define (insert item)
      (let ((new-pair (cons item '())))
        (cond ((empty-queue?)
               (set! front-ptr new-pair)
               (set! rear-ptr new-pair))
              (else
               (set-cdr! read-ptr new-pair)
               (set-rear-ptr! new-pair)))))
    (define (delete-queue! queue)
      ...)
    (define (dispatch m)
      ...)
    dispatch))
#+END_SRC
