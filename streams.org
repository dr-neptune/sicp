* Streams
:PROPERTIES:
:header-args: :session scheme :results verbatim raw
:ARCHIVE:
:END:
In this section, we explore an alternative approach to modeling state, based on data structures called streams. We will see how to model change in terms of sequences that represent the time histories of the systems being modeled. 

From an abstract point of view, a stream is simply a sequence. As an alternative, we also look at the technique of delayed evaluation. 

Stream processing allows us to model systems that have state without ever using assignment or mutable data. 

** Streams are Delayed Lists 

#+BEGIN_SRC scheme
(define (square x)
  (* x x))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(prime? 11)
#+END_SRC

#+BEGIN_SRC scheme
(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

(filter odd? (list 1 2 3 4 5))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(accumulate + 0 (list 1 2 3 4 5))

(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))

(enumerate-interval 2 7)
#+END_SRC

Sequences as standard interfaces for combining program modules allow us some very powerful abstractions, such as map, filter, and accumulate. Unfortunately, representing sequences as lists brings forth a severe inefficiency with regards to time and space complexity. When we represent our manipulations on sequences as transformations of lists, our programs must construct and copy data structures at every step of the process. 

To see why this is true, let us compare two programs for computing the sum of all the prime numbers in an interval.

First, in an imperative style:

#+BEGIN_SRC scheme
(define (sum-primes a b)
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count)
           (iter (+ count 1)
                 (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))

(sum-primes 1 5)
#+END_SRC

And with the sequence operations: 

#+BEGIN_SRC scheme
(define (sum-primes a b)
  (accumulate + 0
              (filter prime?
                      (enumerate-interval a b))))

(sum-primes 1 5)
#+END_SRC

In our first function, our overhead is essentially the local state variables. In the second function, before filter can even begin to look at whether a term is prime or not, enumerate-interval needs to create a list containing all of the possible values. 

Streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as lists. We can formulate programs elegantly as sequence manipulations, while attaining the efficiency of incremental computation. The basic idea is to arrange to construct a stream only partially, and to pass the partial construction to the program that consumes the stream. If the consumer attempts to access a part of the stream that has not yet been constructed, the stream will automatically construct just enough more of itself to produce the required part, thus preserving the illusion that the entire stream exists. 

On the surface, streams are just lists with different names for the procedures that manipulate them. 

#+BEGIN_SRC scheme
(stream-car (cons-stream x y))
(stream-cdr (cons-stream x y))
#+END_SRC
#+BEGIN_SRC scheme
(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each (stream-cdr s)))))

(define (display-stream s)
  (stream-for-each display-line s))

(define (display-line x)
  (newline)
  (display x))
#+END_SRC

To make the stream implementation automatically and transparently interleave the construction of a stream with its use, we will arrange for the cdr of a stream to be evaluated when it is accessed by the stream-cdr procedure rather than when the stream is constructed by cons-stream. 

As a data abstraction, streams are the same as lists. The difference is the time at which the elements are evaluted -- for lists both car and cdr are evaluated at construction time, whereas with streams the cdr is evaluated at selection time. 

Our implementation of streams will be based on a special form called (delay exp). Evaluating (delay exp) doesn't evaluate exp, but returns a delayed object which we can think of as a promise to evaluate exp at some future time. As a companion, there is a procedure called force that takes a delayed object as an argument and performs the evaluation -- in effect forcing delay to fulfill its promise.

cons-stream is a special form defined so that
(cons-stream a b) is equivalent to (con a (delay b))

This means we will construct streams using pairs. Rather than placing the value of the rest of the stream into the cdr of the pair we will put a promise to compute the rest if it is ever requested. 

#+BEGIN_SRC scheme
(define (stream-car stream)
  (car stream))

(define (stream-cdr stream)
  (force (cdr stream)))
#+END_SRC

** The Stream Implementation in Action

Let us analyze the outrageous prime computations reformulated in terms of streams 

#+BEGIN_SRC scheme
(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream low
                   (stream-enumerate-interval (+ low 1) high))))

(stream-car
 (stream-cdr
  (stream-filter prime?
                 (stream-enumerate-interval 10000 1000000))))

(cons 10000 (delay (stream-enumerate-interval 10001 1000000)))
#+END_SRC

#+BEGIN_SRC scheme
(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))

(cons 10007
      (delay (stream-filter prime?
                            (cons 10008
                                  (delay (stream-enumerate-interval 100009 1000000))))))
#+END_SRC

In general, we can think of delayed evaluation as "demand driven" programming, whereby each stage in the stream process is activated only enough to satisfy the next stage. 

** Implementing delay and force 

delay must package an expression so that it can be evaluated later on demand, and we can accomplish this by simply treating the expression as the body of a procedure. delay can be  a special form such that (delay exp) is syntactic sugar for (lambda () exp)

force simply calls the procedure (of no arguments) produced by delay, so we can implemnent force as a procedure:

(define (force delayed-object) (delayed-object))

In order to stop inefficiency with repeated evaluations of the same delayed object, we can build the objects so that the first time they are forced, we store the value they computed. We implement delay as a special-purpose memoized procedure. 

#+BEGIN_SRC scheme
(define (memo-proc proc)
  (let ((already-run? false)
        (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
#+END_SRC 

delay is then defined so that (delay exp) is equivalent to 

(memo-proc (lambda () exp))


*** Exercise 3.50 

Complete the following definition, which generalizes stream-map to allow procedures that take multiple arguments, analogous to map 

#+BEGIN_SRC scheme
(define (stream-map proc . argstreams)
  (if (<??> (car argstreams))
      the-empty-stream
      (<??>
       (apply proc (map <??> argstreams))
       (apply stream-map
              (cons proc (map <??> argstreams))))))
#+END_SRC


#+BEGIN_SRC scheme
(define (stream-map proc . argstreams)
  (if (stream-null? (car argstreams))
      the-empty-stream
      (cons-stream
       (apply proc (map stream-car argstreams))
       (apply stream-map
              (cons proc (map stream-cdr argstreams))))))
#+END_SRC

*** Exercise 3.51 

In order to take a closer look at delayed evaluation, we will use the following procedure, which simply returns its argument after printing it: 

#+BEGIN_SRC scheme
(define (show x)
  (display-line x)
  x)
#+END_SRC

What does the interpreter print in response to evaluating each expression in the following sequence? 

#+BEGIN_SRC scheme :results output
(define x
  (stream-map show (stream-enumerate-interval 0 10)))

(stream-ref x 5)
#+END_SRC
0
1
2
3
4
5

#+BEGIN_SRC scheme :results output
(stream-ref x 7)
#+END_SRC
6
7

*** Exercise 3.52

Consider the sequence of expressions 

#+BEGIN_SRC scheme :results output
(define sum 0)

(define (accum x)
  (set! sum (+ x sum))
  sum)

(define seq
  (stream-map accum
              (stream-enumerate-interval 1 20)))

(define y (stream-filter even? seq))

(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))

(stream-ref y 7)
(display-stream z)
#+END_SRC
;The procedure #[compound-procedure 43 stream-for-each] has been called with 1 argument; it requires exactly 2 arguments.
;To continue, call RESTART with an option number:
; (RESTART 4) => Return to read-eval-print level 4.
; (RESTART 3) => Return to read-eval-print level 3.
; (RESTART 2) => Return to read-eval-print level 2.
; (RESTART 1) => Return to read-eval-print level 1.

5 error> 

What is the value of sum after each of the above expressions is evaluated?

#+BEGIN_SRC scheme
(define sum 0)
sum
#+END_SRC

#+BEGIN_SRC scheme
(define (accum x)
  (set! sum (+ x sum))
  sum)

sum
#+END_SRC

#+BEGIN_SRC scheme
(define seq
  (stream-map accum
              (stream-enumerate-interval 1 20)))

sum
#+END_SRC

This happens because we eagerly evaluate the car of a stream. 

#+BEGIN_SRC scheme
(define y (stream-filter even? seq))
sum
#+END_SRC

Our initial state is a sum of 1. 

Then we ask the stream to filter those elements which are even out 



#+BEGIN_SRC scheme
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))
sum
#+END_SRC

#+BEGIN_SRC scheme
(stream-ref y 7)
#+END_SRC

#+BEGIN_SRC scheme
(display-stream z)
#+END_SRC
What is the printed response to evaluating the stream-ref and display-stream expressions?

Would these responses differ if we had implemented (delay exp) simply as (lambda () exp) without using the optimization provided by memo-proc? explain.

** Infinite Streams 

We can use streams to represent sequences which are infinitely long. 

#+BEGIN_SRC scheme
(define (integers-starting-from n)
  (cons-stream n
               (integers-starting-from (+ n 1))))

(define integers (integers-starting-from 1))

(define (divisible? x y)
  (= (remainder x y) 0))

(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))

(stream-ref no-sevens 100)
#+END_SRC


#+BEGIN_SRC scheme
(define (fibgen a b)
  (cons-stream a (fibgen b (+ a b))))

(define fibs (fibgen 0 1))
#+END_SRC

We can generalize the no-sevens example to construct an infinite stream of prime numbers, using a method known as the sieve of Eratosthenes. 

To sieve a stream S, form a sieve whose first element is the first element of S and the rest of which is obtained by filtering all multiples of the first element of S out of the rest of S and sieving the result. 

#+BEGIN_SRC scheme
(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible?
                   x (stream-car stream))))
           (stream-cdr stream)))))

(define primes (sieve (integers-starting-from 2)))

(stream-ref primes 500)
#+END_SRC

** Defining Streams Implicitly 

The integers and fibs streams above were defined by specifying generating procedures that explicitly compute the stream elements one by one. An alternate way to specify streams is to take advantage of delayed evaluation to define streams implicitly. 

#+BEGIN_SRC scheme
(define ones (cons-stream 1 ones))
#+END_SRC

We can do more interesting things by manipulating streams with operations such as add-streams, which produces the elementwise sum of two given streams: 

#+BEGIN_SRC scheme
(define (add-streams s1 s2)
  (stream-map + s1 s2))

(define integers (cons-stream 1 (add-streams ones integers)))
#+END_SRC

#+BEGIN_SRC scheme
(define fibs
  (cons-stream 0
               (cons-stream 1
                            (add-streams (stream-cdr fibs) fibs))))
#+END_SRC

scale-stream is also useful for formulating such stream definitions 

#+BEGIN_SRC scheme
(define (scale-stream stream factor)
  (stream-map
   (lambda (x) (* x factor))
   stream))

(define double
  (cons-stream 1 (scale-stream double 2)))
#+END_SRC

An alternate definition of the stream of primes can be given by starting with the integers and filtering them by testing for primality. 

#+BEGIN_SRC scheme
(define primes
  (cons-stream 2
               (stream-filter prime?
                              (integers-starting-from 3))))

(define (prime? n)
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))
#+END_SRC

This is a recursive definition, since primes is defined in terms of the prime? predicate, which itself uses the primes stream. The reason this procedure works is that, at any point, enough of the primes stream has been generated to test the primality of the numbers we need to check next. 

That is, for every n we test for primality, either n is not prime (in which case there is a prime already generated that divides it) or n is prime (in which case there is a prime already generated that is less than sqrt(n)) 


*** Exercise 3.53 

Without running the program, describe the elements of the stream defined by 

#+BEGIN_SRC scheme
(define s (cons-stream 1 (add-streams s s)))
#+END_SRC

1 2 4 8 16 32 64 128 256 ...

log_2 growth 

*** Exercise 3.54 

Define a procedure mul-streams, analogous to add-streams that produces the elementwise product of its two input streams. 

#+BEGIN_SRC scheme
(define (mul-streams s1 s2)
  (cons-stream (scale-stream s1 s2)))
#+END_SRC
Use this together with the stream of integers to complete the following definition of the stream whose nth element (counting from 0) is n + 1 factorial.

#+BEGIN_SRC scheme
(define factorials (cons-stream 1 (mul-streams (stream-cdr integers) factorials)))
#+END_SRC

*** Exercise 3.55 

Define a procedure partial-sums that takes as argument a stream S and returns the stream whose elements are s0, s0 + s1, s0 + s1 + s2, ...

For example, (partial-sums integers should be the stream 1, 3, 6, 10, 15, ...)

#+BEGIN_SRC scheme
(define (partial-sums s)
  (add-streams s (cons-stream 0 (partial-sums s))))

(partial-sums integers)
#+END_SRC

*** Exercise 3.56 

A famous problem raised by R. Hamming is to enumerate, in ascending order with no repetitions, all positive integers with no prime factos other than 2, 3, or 5. 

Let us recall the required stream of numbers S and notice the following facts about it:
- S begins with 1
- the elements of (scale-stream S 2) are also elements of S
- The same is true for (scale-stream S 3) and (scale-stream S 5)
- These are all the elements of S


Now all we have to do is combine elements from these sources. This procedure merge combines two ordered streams into one ordered result stream, eliminating repetitions.

#+BEGIN_SRC scheme
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream s1car
                               (merge (stream-cdr s1)
                                      s2)))
                 ((> s1car s2car)
                  (cons-stream s2car
                               (merge s1
                                      (stream-cdr s2))))
                 (else
                  (cons-stream s1car
                               (merge (stream-cdr s1)
                                      (stream-cdr s2)))))))))
#+END_SRC

Then the required stream can be constructed with merge as follows:

#+BEGIN_SRC scheme
(define S (cons-stream 1 (merge (scale-stream S 2) (merge (scale-stream S 3) (scale-stream S 5)))))
#+END_SRC


*** Exercise 3.57

How many additions are performed when we compute the nth fibonacci number using the definition of fibs based on the add-streams procedure? 

As a reminder, here is the fibs defined with add-streams:

#+BEGIN_SRC scheme
(define fibs
  (cons-stream 0
               (cons-stream 1
                            (add-streams (stream-cdr fibs) fibs))))
#+END_SRC

For the first recursion, we add 1 and 0 to get 1
then 1 and 1 to get 2 
then 1 and 2 to get 3 
then 2 and 3 to get 5 

At every iteration we are performing only one addition. Thus the nth fibonacci number will perform n additions. 

Show that the number of additions would have been exponentially greater if we had implemented (delay exp) simply as (lambda () exp), without using the optimization provided by the memo-proc procedure.

This memoized version of fib allows us to add numbers in O(n) time. If we didn't have the memoization, each call back would have to reperform all the previous results. We would be left with a time complexity of A(n) = A(n - 1) + A(n - 2), which is the Fibonacci recurrence relation and comes out to O(phi^n).

*** Exercise 3.58 

Give an interpretation of the stream computed by the following procedure: 

#+BEGIN_SRC scheme
(define (expand num den radix)
  (cons-stream
   (quotient (* num radix)
             den)
   (expand (remainder (* num radix) den)
           den
           radix)))
#+END_SRC

Quotient is a primitive that returns the integer quotient of two integers. 

Interpretation: 

The first element is multiplied by the radix value and then integer divides with quotient. 
The cdr of the stream is the remainder of this value

This stream multiplies each value by a constant, then returns the integer quotient and the remainder after. 

What are the successive elements produced by (expand 1 7 10)?

#+BEGIN_SRC scheme
(expand 1 7 10)
#+END_SRC

1 4 2 8 5 7

10 // 7 == 1 
(expand 3 7 10)
30 // 7 == 4 
(expand 2 7 10)
20 // 7 == 2 
(expand 6 7 10)
60 // 7 == 8 
... 

What about (expand 3 8 10)? 

1 7 5 0 0 0 ... 0 0 0 

This is the result of the floating point integer with the base being radix. 

*** Exercise 3.59

1. Define a procedure integrate-series that takes as input a stream a0 a1 a2 ... and returns a stream a0 1/2 a1, 1/3 a2, ... of coefficients of the non-constant terms of the integral of the series. 

#+BEGIN_SRC scheme
(define (integrate-series S)
  (stream-map / S integers))
#+END_SRC

2. Show how to generate the series for sine and cosine, starting from the facts that the derivative of sine is cosine and the derivative of cosine is -cosine. 

#+BEGIN_SRC scheme
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))

(define cosine-series (cons-stream 1 (integrate-series (scale-stream sine-series -1))))
(define sine-series (cons-stream 0 (integrate-series cosine-series)))
#+END_SRC

*** Exercise 3.60 

With a power series represented as a stream of coefficients, adding series is implemented by add-streams. Complete the definition of the following procedure for multiplying series:

s1 : a0 a1 a2 a3 a4 ...
s2 : b0 b1 b2 b3 b4 ...

s1 x s2: a0b0 + a0b1 + a0b2 + ... +
         a1b0 + a1b1 + a1b2 + ...

#+BEGIN_SRC scheme
(define (mul-series s1 s2)
  (cons-stream (* (stream-car s1)
                  (stream-car s2))
               (add-streams (scale-stream (stream-car s1)
                                          (stream-cdr s2))
                            (mul-series (stream-cdr s1) s2))))
#+END_SRC

#+BEGIN_SRC scheme :results output
(define (display-stream n s)
  (if (< n 0)
      the-empty-stream
      (begin (newline)
             (display (stream-car s))
             (display-stream (- n 1) (stream-cdr s)))))

(define (stream-display s)
  (display-stream 0 s))

(define trig-identity
  (add-streams (mul-series cosine-series cosine-series)
               (mul-series sine-series sine-series)))

 (stream-display trig-identity)
#+END_SRC

*** Exercise 3.61 

Write a procedure invert-unit-series that computes 1/S for a power series S with constant term 1. 

Given: In other words, X is the power series whose constant term is 1 and whose higher-order terms are given by the negative of Sr times X, where (Sr = S - 1, the pasrt of S after the constant term)

#+BEGIN_SRC scheme
(define (invert-unit-series s)
  ())
#+END_SRC


** Exploiting the Stream Paradigm 

The stream approach can be illuminating because it allows us to build systems with different module boundaries than systems organized around assignment to state variables. We can think of an entire time series (or signal) as a focus of interest, rather than the value of the state variables at individual moments. This makes it convenient to combine and compare components of state from different moments. 

** Formulating Iterations as Stream Processes 

We now know that we can represent state as a timeless stream of values rather than as a set of variables to be updated. 

Recall that the idea of our early sqrt procedure is to generate a sequence of better and better guesses for the square root of x:

#+BEGIN_SRC scheme
(define (sqrt-improve guess x)
  (average guess (/ x guess)))
#+END_SRC

From chapter 1:

#+BEGIN_SRC scheme
(define (average x y)
  (/ (+ x y) 2))
#+END_SRC

Instead of updated the state variable over and over, we can generate an infinite stream of guesses, starting with an initial guess of 1:

#+BEGIN_SRC scheme :output results
(define (sqrt-stream x)
  (define guesses
    (cons-stream 1.0
                 (stream-map
                  (lambda (guess)
                    (sqrt-improve guess x))
                  guesses)))
  guesses)

(display-stream 5 (sqrt-stream 2))
#+END_SRC

()
()
1.5
1.4166666666666665
1.4142156862745097
1.4142135623746899
1.414213562373095

We can generate more and more terms of the stream to get better guesses 

#+BEGIN_SRC scheme
(display-stream 50 (sqrt-stream 2))
#+END_SRC

()
()
1.5
1.4166666666666665
1.4142156862745097
1.4142135623746899
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095
1.414213562373095

Another iteration that we can treat the same way is our earlier approximation to pi based on the alternating series for pi / 4.

We first generate the stream of summands of the series, then we take the stream of sums of more and more terms 

#+BEGIN_SRC scheme
(define (pi-summands n)
  (cons-stream
   (/ 1.0 n)
   (stream-map - (pi-summands (+ n 2)))))

(define pi-stream
  (scale-stream
   (partial-sums (pi-summands 1)) 4))

(display-stream 10 pi-stream)
#+END_SRC

Here is the result after 1000 iterations: 3.1425916543395442

Thus far, our use of the stream of states approach is not much different from updating state variables, but states give us an opportunity to do some interesting tricks. For example, we can transform a stream with a sequence accelerator that converts a sequence of approximations to a new sequence that converges to the same value as the original, only faster. 

One such sequence accelerator, due to Euler, works well with sequences that are partial sums of alternating series. 

#+BEGIN_SRC scheme
(define (euler-transform s)
  (let ((s0 (stream-ref s 0))
        (s1 (stream-ref s 1))
        (s2 (stream-ref s 2)))
    (cons-stream
     (- s2 (/ (square (- s2 s1))
              (+ s0 (* -2 s1) s2)))
     (euler-transform (stream-cdr s)))))
#+END_SRC


#+BEGIN_SRC scheme
(display-stream 50 (euler-transform pi-stream))
#+END_SRC

Wow! Much quicker convergence

Even better, we can accelerate the accelerated sequence, and recursively accelerate that, and so on. We can create a stream of streams (a structure we call a tableau) in which each stream is the transform of the preceding ones

#+BEGIN_SRC scheme
(define (make-tableau transform s)
  (cons-stream s
               (make-tableau transform (transform s))))
#+END_SRC

Finally, we form a sequence by taking the first term in each row of the tableau: 

#+BEGIN_SRC scheme :results output
(define (accelerated-sequence transform s)
  (stream-map stream-car (make-tableau transform s)))

(display-stream 10 (accelerated-sequence euler-transform pi-stream))
#+END_SRC

4.
3.166666666666667
3.142105263157895
3.141599357319005
3.1415927140337785
3.1415926539752927
3.1415926535911765
3.141592653589778
3.1415926535897953
3.141592653589795

*** Exercise 3.63 

Louis Reasoner asks why the sqrt-stream procedure wasn't written in the following way: 

#+BEGIN_SRC scheme
(define (sqrt-stream x)
  (cons-stream 1.0
               (stream-map (lambda (guess)
                             (sqrt-improve guess x))
                           (sqrt-stream x))))
#+END_SRC

Alyssa P Hacker replies that this version of the procedure is less efficient because it performs redundant computation. Explain her answer

*** Exercise 3.64 

Write a procedure stream-limit that takes as arguments a stream and a number (the tolerance). It should examine the stream until it finds two successive elements that differ in absolute value by less than the tolerance, and return the second of the two elements. 

#+BEGIN_SRC scheme
(define (s-val s n)
  (stream-ref s n))

(define (stream-limit s tol)
  (if (< (abs (- (s-val s 0)
                 (s-val s 1)))
         tol)
      (s-val s 1)
      (stream-limit (stream-cdr s) tol)))
#+END_SRC

Using this we could compute 

#+BEGIN_SRC scheme
(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))

(sqrt 2 0.00001)
#+END_SRC

1.4142135623746899

*** Exercise 3.65 

Use the series 

ln 2 = 1 - 1/2 + 1/3 - 1/4 + ...

to compute 3 sequences of approximations to the natural log of 2, in the same way we did about for pi.

#+BEGIN_SRC scheme
(define (pi-summands n)
  (cons-stream
   (/ 1.0 n)
   (stream-map - (pi-summands (+ n 2)))))

(define pi-stream
  (scale-stream
   (partial-sums (pi-summands 1)) 4))
#+END_SRC

#+BEGIN_SRC scheme
(define (ln2-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (ln2-summands (+ n 1)))))

(define ln2-stream
  (partial-sums (ln2-summands 1)))

(display-stream 10 ln2-stream)
#+END_SRC

This takes a lot of iterations to converge. Even after 100 there is still a lot of error.

Now to accelerate it.

#+BEGIN_SRC scheme
(display-stream 10 (accelerated-sequence euler-transform ln2-stream))
#+END_SRC

This method converges within 10 steps, and looks great by the 3rd step 

** Infinite Streams of Pairs 

If we generalize this technique to infinite streams, then we can write programs that are not easily represented as loops, because the looping must range over an infinite set. 

Suppose we want to generalize the prime-sum-pairs procedure to produce the stream of pairs of all integers (i, j) such that i + j is prime. 

If int-pairs is the sequence of all pairs of integers (i, j) with i leq j, then our required stream is simply:

#+BEGIN_SRC scheme
(stream-filter
 (lambda (pair)
   (prime? (+ (car pair)
              (cadr pair))))
 int-pairs)
#+END_SRC
our problem, then, is to produce the stream int-pairs.

We can form a stream of pairs as follows:

#+BEGIN_SRC scheme
(define (pairs s t)
  (cons-stream
   (list (stream-car s)
         (stream-car t))
   (combine-in-some-way
    (stream-map (lambda (x)
                  (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s)
           (stream-cdr t)))))
#+END_SRC



In order to complete the procedure, we must choose some way to combine the two inner streams 

#+BEGIN_SRC scheme
(define (stream-append s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream
       (stream-car s1)
       (stream-append (stream-cdr s1) s2))))
#+END_SRC


This isn't suitable for infinite streams because it takes all the elements from the first stream before incorporating the second stream. To handle infinite streams, we need to devise an order of combination that ensures that every element will eventually be reached if we let our program run long enough

#+BEGIN_SRC scheme
(define (interleave s1 s2)
  (if (stream-null? s2)
      s2
      (cons-stream
       (stream-car s1)
       (interleave s2 (stream-cdr s1)))))
#+END_SRC

We can thus generate the required stream of pairs as 

#+BEGIN_SRC scheme
(define (pairs s t)
  (cons-stream
   (list (stream-car s)
         (stream-car t))
   (interleave
    (stream-map (lambda (x)
                  (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s)
           (stream-cdr t)))))

#+END_SRC


*** Exercise 3.66

Examine the stream (pairs integers integers)

#+BEGIN_SRC scheme
(display-stream 10 (pairs integers integers))
#+END_SRC

(1 1)
(1 2)
(2 2)
(1 3)
(2 3)
(1 4)
(3 3)
(1 5)
(2 4)
(1 6)
(3 4)

Can you make any general comments about the order in which the pairs are placed into the stream? 

These are ordered in the way that Cantor proved the uncountability of real numbers, with diagonalization.

Approximately how many pairs precede the pair (1, 100)?

for the first pair (1, 1) there is one pair 
for the second diagonal there are two pairs (2, 1) (1, 2) but these are equivalent so we have 1
for the third diagonal there are 3 pairs (3, 1), (2, 2), (1, 3) but the first and last are equivalent so we have 2
for the fourth diagonal there are 4 pairs (4, 1), (3, 2), (2, 3), (1, 4) but these are all duplicated so we have 2 
for the fifth diagonal there are 5 pairs (5, 1), (4, 2), (3, 3), (2, 4), (1, 5) but there are two duplicated sets so we have 3 

Overall for the nth row we have ceiling(n, 2) pairs. So to get the number of pairs that precede the pair (1, 100) we have

sum_{i = 1}^100 (ceiling (i, 2)) pairs

1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + ...
1 + ((sum 1->100) - 1) * 2

1 - 1 + n(n-1) / 2 ~ 100 * 99 / 2 * 2 = 9900 

for (100, 100)

*** Exercise 3.67 

Modify the pairs procedure so that (pairs integers integers) will produce the stream of all pairs of integers.

Hint: you will need to mix in an additional stream 

idea: mix the original with the inverse which shows all pairs with the condition i > j

#+BEGIN_SRC scheme

(define (pairs s t)
  (cons-stream
   (list (stream-car s) ; first pair
         (stream-car t))
   (interleave
    (stream-map (lambda (x) ; rest of first row
                  (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) ;recurse to remaining pairs 
           (stream-cdr t)))))

#+END_SRC

#+BEGIN_SRC scheme
(define (pairs s t)
  (define (pairs-rev s t)
    (cons-stream
     (list (stream-car t)
           (stream-car s))
     (interleave
      (stream-map (lambda (x)
                    (list (stream-car t) x))
                  (stream-cdr s))
      (pairs-rev (stream-cdr t)
                 (stream-cdr s)))))
  (interleave
   (pairs s t)
   (pairs-rev s t)))
#+END_SRC

didn't work 

From the book: 

Call the general stream of pairs (pairs S T) and consider it to be composed of 3 parts: the pair (s0, t0), the rest of the pairs in the first row, and the remaining pairs. 

The rest of the first row is (stream-map (lambda (x) (list (stream-car s) x)) (stream-cdr t))
The remaining pairs are (pairs (stream-cdr s)(stream-cdr t)). Since we recurse on both, we get the diagonal effect 

#+BEGIN_SRC scheme
(define (pairs s t)
  (cons-stream
   (list (stream-car s)
         (stream-car t)) ; first pair
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t)) ; rest of first row
    (pairs (stream-cdr s) t)))) ; recurse downwards only. interleave will handle the dispersion
#+END_SRC

*** Exercise 3.68 

Louis thinks building a stream from 3 pairs in unnecessarily complicated. Instead of separating the first pair he proposes to work with the whole first row

#+BEGIN_SRC scheme
(define (pairs s t)
  (interleave
   (stream-map
    (lambda (x)
      (list (stream-car s) x))
    t)
   (pairs (stream-cdr s)
          (stream-cdr t))))
#+END_SRC

It goes into an infinite loop. I'm not sure why. 

Here is the definition of interleave: 

#+BEGIN_SRC scheme
(define (interleave s1 s2)
  (if (stream-null? s2)
      s2
      (cons-stream
       (stream-car s1)
       (interleave s2 (stream-cdr s1)))))
#+END_SRC

*** Exercise 3.69 

Write a procedure triples that takes three infinite streams, S, T, and U, and produces the stream of triples (si, tj, uk) such that i leq j leq k. 

#+BEGIN_SRC scheme
(define (triples s t u)
  (pairs s (pairs t u)))

(display-stream 10 (triples integers integers integers))

#+END_SRC
#+BEGIN_SRC scheme
(define (triples s t u)
  (cons-stream
   (list (stream-car s)
         (stream-car t)
         (stream-car u))
   (interleave
     (stream-map (lambda (x)
                   (cons (stream-car s) x))
                 (stream-cdr (pairs t u)))
    (triples (stream-cdr s)
             (stream-cdr t)
             (stream-cdr u)))))
#+END_SRC

Use triples to generate the stream of all Pythagorean triples of positive integers.

#+BEGIN_SRC scheme
(define (py-pred a b c)
  (if (= (+ (square a)
            (square b))
         (square c))
      #t
      #f))

(py-pred 3 4 5)

(define (py-trips trips)
  (stream-filter (lambda (trips) (py-pred (car trips) (cadr trips) (caddr trips))) trips))

(define trips (triples integers integers integers))

(py-trips trips)
#+END_SRC
This is a very slow computation. Here are the first 6: 

(3 4 5)
(6 8 10)
(5 12 13)
(9 12 15)
(8 15 17)
(12 16 20)


*** Exercise 3.70 

We wish for our streams to generate pairs in some useful order rather than their current interleaved pattern. One way to do this is to define a weighting function W(i, j) and stipulate that (i1, j1) is less than (i2, j2) if W(i1, j1) < W(i2, j2). 

Write a procedure merge-weighted that takes an additional argument weight, which is then a procedure which computes the weight of a pair, and is used to determine the order in which elements should appear in the resulting merged stream. 

A note on let*: 

Like let, but evaluates the val-exprs one by one, creating a location for each id as soon as the value is available. The ids are bound in the remaining val-exprs as well as the bodys, and the ids need not be distinct; later bindings shadow earlier bindings.

#+BEGIN_SRC scheme
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (let ((s1car (stream-car s1))
              (s2car (stream-car s2)))
          (cond ((< s1car s2car)
                 (cons-stream s1car
                              (merge (stream-cdr s1)
                                     s2)))
                ((> s1car s2car)
                 (cons-stream s2car
                              (merge s1
                                     (stream-cdr s2))))
                (else
                 (cons-stream s1car
                              (merge (stream-cdr s1)
                                     (stream-cdr s2))))))))

; this part is essentially rewriting merge with the weighting
(define (merge-weighted s1 s2 weight)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let* ((s1car (stream-car s1))
                (s2car (stream-car s2))
                (ws1 (weight s1car))
                (ws2 (weight s2car)))
           (cond ((< ws1 ws2)
                  (cons-stream s1car
                               (merge-weighted (stream-cdr s1)
                                               s2
                                               weight)))
                 ((> ws1 ws2)
                  (cons-stream s2car
                               (merge-weighted s1
                                               (stream-cdr s2)
                                               weight)))
                 (else
                  (cons-stream
                   s2car
                   (cons-stream s1car
                                (merge-weighted (stream-cdr s1)
                                                (stream-cdr s2)
                                                weight)))))))))
#+END_SRC
Using this generalize pairs to produce a procedure weighted-pairs that generates a stream of pairs according to weight. 

#+BEGIN_SRC scheme
(define (pairs s t)
  (cons-stream
   (list (stream-car s) ; first pair
         (stream-car t))
   (interleave
    (stream-map (lambda (x) ; rest of first row
                  (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) ;recurse to remaining pairs 
           (stream-cdr t)))))

(define (weighted-pairs s1 s2 weight)
  (cons-stream
   (list (stream-car s1)
         (stream-car s2))
   (merge-weighted
    (stream-map (lambda (x)
                  (list (stream-car s1) x))
                (stream-cdr s2))
    (weighted-pairs (stream-cdr s1) (stream-cdr s2) weight)
    weight)))
#+END_SRC

Then generate

1. The stream of all pairs of positive integers with i leq j ordered according to the sum i + j 

#+BEGIN_SRC scheme
(define by-sum (weighted-pairs integers integers (lambda (pair) (+ (car pair) (cadr pair)))))

(define by-sum-filtered (stream-filter (lambda (pair) (<= (car pair) (cadr pair))) by-sum))

(display-stream 5 by-sum-filtered)
#+END_SRC
2. The stream of all pairs of positive integers i, j with i leq j, where neither i nor j is divisible by 2, 3, or 5 and the pairs are ordered according to the sum 2i + 3j + 5ij. 

#+BEGIN_SRC scheme
(define (ttf-pred pair)
    (+ (* 2 (car pair))
       (* 3 (cadr pair))
       (* 5 (* (car pair)
               (cadr pair)))))

(define (div-pred n)
  (not (or (even? n)
           (zero? (remainder n 3))
           (zero? (remainder n 5)))))

(define (leq-pred pair)
  (<= (car pair)
      (cadr pair)))

(define (tog-pred pair)
    (and (leq-pred pair)
         (div-pred (car pair))
         (div-pred (cadr pair))))

(define cstream
  (stream-filter tog-pred (weighted-pairs integers integers ttf-pred)))

(display-stream 5 cstream)
#+END_SRC
*** Exercise 3.71 

Numbers that can be expressed at the sum of two cubes in more than one way are sometimes called Ramanujan numbers.

To find a number that can be written as the sum of two cubes in two different ways, we need only generate the streams of pairs of integers (i, j) weighted according to the sum i^3 + j^3, then search the stream for two consecutive pairs with the same weight. Write a procedure to generate the Ramanujan numbers.

#+BEGIN_SRC scheme
(define (cube-weighted pair)
  (define (cube x)
    (* x x x))
  (+ (cube (car pair))
     (cube (cadr pair))))

(define (ramanujan-stream s)
  (let ((scar (stream-car s))
        (scadr (stream-car (stream-cdr s))))
    (if (= (cube-weighted scar)
           (cube-weighted scadr))
        (cons-stream (list (cube-weighted scadr)
                           scar
                           scadr)
                     (ramanujan-stream (stream-cdr (stream-cdr s))))
        (ramanujan-stream (stream-cdr s)))))

(define ramnum
  (ramanujan-stream (weighted-pairs integers integers cube-weighted)))
#+END_SRC

Woo! The results:

(1729   (9 10) (1 12))
(4104   (9 15) (2 16))
(13832 (18 20) (2 24))
(20683 (19 24) (10 27))
(32832 (18 30) (4 32))
(39312 (15 33) (2 34))

*** Exercise 3.72 

In a way similar to 3.71, generate a stream of all numbers that can be written as the sum of two squares in 3 different ways 

#+BEGIN_SRC scheme
(define (ss-weighted pair)
  (define (square x)
    (* x x))
  (+ (square (car pair))
     (square (cadr pair))))

(define (ss-stream s)
  (let ((scar (stream-car s))
        (scadr (stream-car (stream-cdr s)))
        (scaddr (stream-car (stream-cdr (stream-cdr s)))))
    (if (= (ss-weighted scar)
           (ss-weighted scadr)
           (ss-weighted scaddr))
        (cons-stream (list (ss-weighted scar)
                           scar
                           scadr
                           scaddr)
                     (ss-stream (stream-cdr (stream-cdr s))))
        (ss-stream (stream-cdr s)))))

(define ss-str-out
  (ss-stream (weighted-pairs integers integers ss-weighted)))
#+END_SRC

Very cool: 

(325 (10 15) (1 18) (6 17))
(425 (13 16) (5 20) (8 19))
(650 (17 19) (5 25) (11 23))
(725 (14 23) (7 26) (10 25))
(845 (19 22) (2 29) (13 26))
(850 (15 25) (3 29) (11 27))

** Streams as Signals

We can use streams to model signal-processing systems in a very direct way, representing the values of a signal at successive time intervals as consecutive elements of a stream. 

#+BEGIN_SRC scheme
(define (integral integrand initial-value dt)
  (define int
    (cons-stream
     initial-value
     (add-streams (scale-stream integrand dt)
                  int)))
  int)
#+END_SRC

*** Exercise 3.73 

Write a procedure RC that models the given circuit 

#+BEGIN_SRC scheme
(define (RC r c dt)
  (define (voltages current initial-value)
    (add-streams
     (scale-stream current r)
     (scale-stream (/ 1 c)
                   (integral current initial-value dt))))
  voltages)
#+END_SRC

*** Exercise 3.74 

Complete the equivalent programs:

#+BEGIN_SRC scheme
(define (make-zero-crossings input-stream last-value)
  (cons-stream
   (sign-change-detector
    (stream-car input-stream)
    last-value)
   (make-zero-crossings
    (stream-cdr input-stream)
    (stream-car input-stream))))

(define zero-crossings
  (make-zero-crossings sense-data 0))
#+END_SRC

#+BEGIN_SRC scheme
(define zero-crossings
  (stream-map sign-change-detector
              sense-data
              <expression>))
#+END_SRC

#+BEGIN_SRC scheme
(define zero-crossings
  (stream-map
   sign-change-detector
   sense-data
   (stream-cdr sense-data)))
#+END_SRC

*** Exercise 3.75 

Louis Reasoner attempts to implement the idea of a smoothed zero-crossing detector. 

#+BEGIN_SRC scheme
(define (make-zero-crossings input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream)
                    last-value)
                 2)))
    (cons-stream
     (sign-change-detector avpt last-value)
     (make-zero-crossings
      (stream-cdr input-stream) avpt))))
#+END_SRC

This doesn't work. Find the bug and fix it without changing the structure of the program.


