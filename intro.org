* Scheme
  :PROPERTIES:
  :header-args: :session intro :results verbatim raw
  :END:

Add this to your init file

#+BEGIN_SRC elisp
(defun tws-insert-scheme-chunk () 
  (interactive) 
  (insert (concat "#+BEGIN_SRC scheme" "\n\n#+END_SRC")) 
  (forward-line -1))

(global-set-key (kbd "C-c d") 'tws-insert-scheme-chunk)

(add-hook 'scheme-mode-hook 'geiser-mode)
(require 'scheme)
(setq geiser-active-implementations '(mit))
(custom-set-variables '(scheme-program-name "mit-scheme"))

;; Org Babel
(org-babel-do-load-languages
 'org-babel-load-languages
 '((R . t)
   (shell . t)
   (scheme . t)))
#+END_SRC

#+RESULTS:
: nil

---------

#+BEGIN_SRC scheme
(define x "foop")

(+ 1 2 3 4 5 6 7 8 9 10)
#+END_SRC

#+RESULTS:
55

#+BEGIN_SRC scheme 
(+ 1 2 3)
x
#+END_SRC

#+RESULTS:
"foop"

#+BEGIN_SRC scheme
(define (square x)
  (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 10 25)
#+END_SRC

#+RESULTS:
725

** 1. Building Abstractions with Procedures

*** 1.1 | The Elements of Programming

 A programming language serves as a framework with which we organize our ideas about processes. We should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas.

 - primitive expressions, which represent the simplest entities the language is concerned with
 - means of combination, by which compound elements are built from simpler ones
 - means of abstraction, by which compound elements can be named and manipulated as units

**** 1.1.1 | Expressions

#+BEGIN_SRC scheme
(+ 137 349)
(- 1000 334)
(* 55 99)
(/ 10 5)
(+ 2.7 10)
 #+END_SRC

#+BEGIN_SRC scheme
(+ (* 3 5) (- 10 6))
#+END_SRC

#+RESULTS:
19

#+BEGIN_SRC scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
#+END_SRC

#+RESULTS:
57

**** 1.1.2 | Naming and the Environment

#+BEGIN_SRC scheme
(define size 2)
size
#+END_SRC

#+RESULTS:
2

#+BEGIN_SRC scheme
(* 5 size)
#+END_SRC

#+RESULTS:
10

#+BEGIN_SRC scheme
(define pi 3.14159)
(define radius 10)

(* pi (* radius radius))

(define circumference (* 2 pi radius))
circumference
#+END_SRC

#+RESULTS:
314.159
62.8318

**** 1.1.3 | Evaluating Combinations

To evaluate a combination, do the following: 

1. Evaluate the subexpressions of the combination
2. Apply the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpressions (the operands)

The evaluation rule is recursive in nature; it includes, as one of its steps, the need to invoke the rule itself. Recursion, in general, is a very powerful technique for dealing with hierarchical, treelike objects. The "percolate values upward" form of the evaluation rule is an example of a general kind of process known as tree accumulation.



